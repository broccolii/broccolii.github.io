<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="不求深刻,但求简单."><title>ReactiveCocoa 整理 | 一朵西兰花</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/rss+xml" href="/rss2.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ReactiveCocoa 整理</h1><a id="logo" href="/.">一朵西兰花</a><p class="description">不求深刻,但求简单.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ReactiveCocoa 整理</h1><div class="post-meta">Dec 31, 2015<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2015/12/31/ReactiveCocoa_exploration/" href="/2015/12/31/ReactiveCocoa_exploration/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a>（简称为RAC）,是由 Github 开源的一个应用于iOS和OS开发的新框架.是一个 iOS 中的函数式响应式编程框架.(注: 文本例子使用 ReactiveCocoa 2.5)</p>
<h3 id="ReactiveCocoa__u7684_u4F5C_u7528"><a href="#ReactiveCocoa__u7684_u4F5C_u7528" class="headerlink" title="ReactiveCocoa 的作用"></a>ReactiveCocoa 的作用</h3><p>在 iOS 开发过程中,我们需要监听不同的事件,并作出反应,例如对 <code>UIButton</code> 的点击事件使用 <code>TA</code> 模式,对 <code>UIScrollView</code> 的滚动事件使用 <code>delegate</code>,对属性变化监听使用 <code>KVO</code>.那么我们可能会想能不能使用同一的标准? <code>ReactiveCocoa</code> 为我们提供了一个单独的、统一的方法来这些行为.它可以把要处理的事情,和监听的事情的代码放在一起,便于我们管理代码,非常符合我们开发中<code>高聚合,低耦合</code>的思想.</p>
<h3 id="u7F16_u7A0B_u8303_u5F0F_3A__u51FD_u6570_u5F0F_u7F16_u7A0B_/__u54CD_u5E94_u5F0F_u7F16_u7A0B"><a href="#u7F16_u7A0B_u8303_u5F0F_3A__u51FD_u6570_u5F0F_u7F16_u7A0B_/__u54CD_u5E94_u5F0F_u7F16_u7A0B" class="headerlink" title="编程范式: 函数式编程 / 响应式编程"></a>编程范式: 函数式编程 / 响应式编程</h3><p><em>ReactiveCocoa被描述为函数响应式编程（FRP）框架,使用 FRP 有两个好处: 直观和灵活.</em><br><strong>函数式编程(Functional Programming)</strong><br>函数式编程(functional programming)简单的来说就是一种编程范型,主要思想是把运算过程尽量写成一系列嵌套的函数调用.函数编程语言最重要的基础是 λ 演算(lambda calculus),而且 λ 演算的函数可以接受函数当作输入和输出.函数式编程更加强调程序执行的结果而非执行的过程,倡导利用若干简单的执行单元让计算结果不断渐进,逐层推导复杂的运算,而不是设计一个复杂的执行过程.<br>阮一峰老师有一个关于<a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank" rel="external">函数式编程</a>的例子,如下:</p>
<blockquote>
<p>举例来说,现在有这样一个数学表达式：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span> + <span class="number">2</span>) * <span class="number">3</span> - <span class="number">4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可能会这样写:</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> a</span> = <span class="number">1</span> + <span class="number">2</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> b</span> = a * <span class="number">3</span>　　</span><br><span class="line"><span class="variable"><span class="keyword">var</span> c</span> = b - <span class="number">4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数式编程要求使用函数,我们可以把运算过程定义为不同的函数,然后写成下面这样：</p>
</blockquote>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">result</span> = subtract(multiply(add(<span class="number">1</span>,<span class="number">2</span>), <span class="number">3</span>), <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这就是函数式编程</p>
</blockquote>
<p><strong>响应式编程(Reactive Programming).</strong><br>响应式编程是一种面向数据流和变化传播的编程范式.这意味着可以在编程语言中很方便地表达静态或动态的数据流,而相关的计算模型会自动将变化的值通过数据流进行传播.我们看一下刚刚阮老师的代码 <code>var b = a * 3</code> 如果 <code>a</code> 的值从 3 变成了 5, 那么 <code>b</code> 的值会随着 <code>a</code> 的变化而变化. <code>b</code> 的值就从 9 变为了 15.</p>
<h3 id="ReactiveCocoa__u57FA_u672C_u6982_u5FF5"><a href="#ReactiveCocoa__u57FA_u672C_u6982_u5FF5" class="headerlink" title="ReactiveCocoa 基本概念"></a>ReactiveCocoa 基本概念</h3><p><strong>RACSignal</strong><br>ReactiveCocoa 的核心就是 RACSignal,也就是信号,我们可以直接创建信号 <code>createSignal</code>,并发送 <code>sendNext</code> 进行下一步操作,当信号完成后我们可以调用 <code>sendCompleted</code>,我们同时用 <code>dispose</code> 方法销毁它 .当然如果信号因为发生错误而终止,也可以发送错误信号 <code>sendError</code>.当我们使用了 <code>sendCompleted</code> 和 <code>sendError</code> 就不能继续发送 <code>sendNext</code>,因为信号已经终止结束.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建信号</span></span><br><span class="line">RACSignal *signal = [RACSignal <span class="string">createSignal:</span>^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">	<span class="comment">// 发送信号</span></span><br><span class="line">   [subscriber <span class="string">sendNext:</span>@<span class="string">"下一步"</span>];</span><br><span class="line">   [subscriber <span class="string">sendError:</span>[NSError <span class="keyword">new</span>]];</span><br><span class="line">   [subscriber sendCompleted];</span><br><span class="line">   <span class="comment">// 取消订阅</span></span><br><span class="line">   <span class="keyword">return</span> [RACDisposable <span class="string">disposableWithBlock:</span>^&#123;</span><br><span class="line">      <span class="comment">// 信号被销毁时调用</span></span><br><span class="line">   &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>如下图所示: 我们可以使用 RACSignal 可以来替代 iOS 中传统的 Delegate,Block,Target Action,KVO,Notification.</p>
<div style="text-align: center"><br><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/ReactiveCocoa_exploration/RACSignal.jpg"><br></div>

<p>创建了一个信号,需要有订阅者来接受它,否则它就是一个待激活的状态.可以使用 <code>subscribeNext:</code> 激活信号.此时有了订阅者,才会发生 <code>sendNext:</code>, <code>sendError:</code>, <code>sendCompleted</code>. 所以一个信号的正确流程应该是 1. 创建信号,2. 订阅信号, 3. 发送信号.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅信号</span></span><br><span class="line">[signal <span class="string">subscribeNext:</span>^(id x) &#123;</span><br><span class="line">   <span class="comment">// 接收 next 操作</span></span><br><span class="line">&#125; <span class="string">error:</span>^(NSError *error) &#123;</span><br><span class="line">   <span class="comment">// 接收 error 操作</span></span><br><span class="line">&#125; <span class="string">completed:</span>^&#123;</span><br><span class="line">   <span class="comment">// 接收 complete 操作</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><strong>RACSubscriber</strong><br>我们现在对信号的产生和发送有了一些了解, 在 ReactiveCocoa 中,其实并不存在一个订阅者的实例,凡是实现 <code>RACSubscriber</code> 协议的类都可以作为订阅者.<br>协议里有四个方法</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@protocol</span> RACSubscriber &lt;NSObject&gt;</span><br><span class="line"><span class="annotation">@required</span></span><br><span class="line"></span><br><span class="line">- (<span class="typename">void</span>)<span class="string">sendNext:</span>(id)value;</span><br><span class="line">- (<span class="typename">void</span>)<span class="string">sendError:</span>(NSError *)error;</span><br><span class="line">- (<span class="typename">void</span>)sendCompleted;</span><br><span class="line">- (<span class="typename">void</span>)<span class="string">didSubscribeWithDisposable:</span>(RACCompoundDisposable *)disposable;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>-sendNext:</code>,<code>-sendError:</code> 和 <code>-sendCompleted</code>,刚刚我们用于发送了不同类型的信号, 而 <code>didSubscribeWithDisposable:</code> 用于接收代表某次订阅的 disposable 对象,告诉订阅者你订阅了哪些信号.我们也可以用返回的 <code>RACDisposable</code> 手动取消订阅者</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RACDisposable *disposable = [signal <span class="string">subscribeNext:</span>^(id x) &#123;</span><br><span class="line">   <span class="comment">// 接收 next 操作</span></span><br><span class="line">&#125; <span class="string">error:</span>^(NSError *error) &#123;</span><br><span class="line">   <span class="comment">// 接收 error 操作</span></span><br><span class="line">&#125; <span class="string">completed:</span>^&#123;</span><br><span class="line">   <span class="comment">// 接收 complete 操作</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 手动取消订阅者    </span></span><br><span class="line">[disposable dispose];</span><br></pre></td></tr></table></figure>
<p>RACSignal 默认替我们实现了 <code>RACSubscriber</code> 协议,点进 RACSignal 的源码可以在 <code>@implementation RACSignal (Subscription)</code> 看到,实现订阅者的方法.这里有一个与 <code>RACSubscriber</code> 协议同名的 <code>RACSubscriber</code>类.这与 <code>NSObject</code> 协议与 <code>NSObject</code>类同名类似. <code>RACSubscriber</code> 类就是真正的订阅者,不过在 ReactiveCocoa 中,倾向于隐藏订阅者,让程序员只关注信号就可以了.</p>
<p><strong>RACDisposable</strong><br>RACDisposable 用于取消订阅与资源清理(cancellation and resource cleanup).当信号发送完成或发送错误的时候,就会自动触发 <code>[disposable dispose];</code>.</p>
<p><strong>RACSubject</strong><br>RACSubject 是一个可以手动控制的信号,我们可以把它看作是 RACSignal 的可变版本.RACSubject 继承自 RACSignal ,所以它可以作为信号源被订阅者订阅,同时,它又实现了 RACSubscriber 协议,所以它也可以作为订阅者订阅其他信号源. RACSubject 可以看作是信号的一个可变体(variant),就像NSMutableArray之于NSArray.它对于桥接(bridging)非RAC代码到信号中去(into the world of signals)非常有用.RACSubject 的功能非常强大,但是太过灵活,也正是因为如此,我们只有在迫不得已的情况下才会使用它.</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">RACSubject</span> *<span class="atom">signal</span> = [<span class="name">RACSubject</span> <span class="atom">subject</span>];</span><br><span class="line">[<span class="atom">signal</span> <span class="atom">subscribeNext</span>:^(<span class="atom">id</span> <span class="atom">x</span>) &#123;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[<span class="atom">signal</span> <span class="atom">sendNext</span>:@<span class="string">"signal"</span>];</span><br></pre></td></tr></table></figure>
<p><strong>RACSequence</strong><br>RACSequence 类可以简单看做是 ReactiveCocoa 的 NSArray, ReactiveCocoa使用 <code>rac_sequence</code> 方法,可以使 Objective-C 中的集合类（collection classes）直接转换为RACSequence 来使用</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">NSArray</span> *numbers = <span class="annotation">@[<span class="variable">@1</span>,<span class="variable">@2</span>,<span class="variable">@3</span>,<span class="variable">@4</span>]</span>;</span><br><span class="line">[numbers.rac_sequence.signal <span class="symbol">subscribeNext:</span>^(id x) &#123;</span><br><span class="line"><span class="regexp">//</span> 遍历数组</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><strong>RACScheduler</strong><br>RACScheduler 在 ReactiveCocoa 中类似 GCD 的队列,是管理线程的一个类.负责 ReactiveCocoa 中让信号发出的事件在线程中穿梭,尤其是想更新 UI 必须在主线程中的时候,可以让事件直接从其他线程跳到主线程.本质上它是基于 GCD 的串行队列实现,并且支持取消操作.</p>
<p><strong>RACMulticastConnection</strong><br>RACMulticastConnection 是一个在任意数量订阅者之间共享的一个订阅者(subscription).<br>信号在默认情况下是冷的,每当添加一个新的订阅,信号的 block 就会被调用一次,如果 block 中实现的是网络请求,那么会发生多次请求.(这里与 replay 不同的是,replay 是会产生多次信号,不过只发送第一次的,而 RACMulticastConnection 只会产生一次)</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"网络请求"</span>);</span><br><span class="line">   [subscriber sendNext:<span class="string">@"signal"</span>];</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACMulticastConnection *connect = [signal publish];</span><br><span class="line"></span><br><span class="line">[connect<span class="variable">.signal</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[connect<span class="variable">.signal</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.连接,激活信号</span></span><br><span class="line">[connect connect];</span><br></pre></td></tr></table></figure>
<h3 id="ReactiveCocoa__u4E2D_u7684_u5E38_u7528_u5F02_u6B65_u5904_u7406"><a href="#ReactiveCocoa__u4E2D_u7684_u5E38_u7528_u5F02_u6B65_u5904_u7406" class="headerlink" title="ReactiveCocoa 中的常用异步处理"></a>ReactiveCocoa 中的常用异步处理</h3><ul>
<li>Delegate (有局限,只能取代没有返回值的代理方法)</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="keyword">self</span> rac_signalForSelector:<span class="keyword">@selector</span>(textFieldDidBeginEditing:)</span><br><span class="line"> fromProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">UITextFieldDelegate</span>)]</span></span><br><span class="line"> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="comment">// 代理方法</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<ul>
<li>Target-Action</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[button rac_signalForControlEvents:UIControlEventTouchUpInside]</span></span><br><span class="line"> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">// 点击事件  </span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>KVO</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[RACObserve<span class="list">(<span class="keyword">scrollView</span>, contentOffset)</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">// 监听 scrollView 的偏移量</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Notification</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[NSNotificationCenter defaultCenter]</span> rac_addObserverForName:UIApplicationDidEnterBackgroundNotification object:nil]</span> subscribeNext:^<span class="list">(<span class="keyword">NSNotification</span> * notification)</span> <span class="collection">&#123;</span><br><span class="line">// 收到通知 </span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定时器</li>
</ul>
<p>1.延迟一段时间后再做某件事</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[[RACScheduler mainThreadScheduler]</span> <span class="tag">afterDelay</span><span class="pseudo">:2</span> <span class="tag">schedule</span>:^&#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>2.每个一定长度时间做一件事</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[RACSignal interval:1 onScheduler:<span class="collection">[RACScheduler mainThreadScheduler]</span>]</span>subscribeNext:^<span class="list">(<span class="keyword">NSDate</span> * date)</span> <span class="collection">&#123;</span><br><span class="line">// do something</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>手势</li>
</ul>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UITapGestureRecognizer *tap = <span class="comment">[<span class="comment">[UITapGestureRecognizer alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[<span class="comment">[tap rac_gestureSignal]</span> subscribeNext:^(UITapGestureRecognizer * tap) &#123;</span><br><span class="line">// 手势操作</span><br><span class="line">&#125;]</span>;</span><br><span class="line"><span class="comment">[self.view addGestureRecognizer:tap]</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>文本框文字改变 </li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[textField rac_textSignal]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="u5B8F_u5B9A_u4E49"><a href="#u5B8F_u5B9A_u4E49" class="headerlink" title="宏定义"></a>宏定义</h3><p><strong>RAC()</strong> 可以将 RACSignal 发出事件的值赋给某个对象的某个属性</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(self.labelView,<span class="keyword">text</span>) = <span class="keyword">textField</span>.rac_textSignal;</span><br></pre></td></tr></table></figure>
<p><strong>RACObserve()</strong> 新建一个 <code>RACSignal</code> 并对对象的属性的值进行观察</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[RACObserve<span class="list">(<span class="keyword">textField</span>, text)</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">// 当 text 发生改变时,会接收到信号</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>RACTuplePack</strong> 把数据包装成 RACTuple 类型</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACTuple *tuple = RACTuplePack(<span class="constant">@10</span>,<span class="constant">@20</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>RACTupleUnpack</strong> 把 RACTuple 类型解包</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// num1 = 10, num2 = 20</span></span><br><span class="line">RACTupleUnpack(<span class="built_in">NSNumber</span> *num1,<span class="built_in">NSNumber</span> *num2) = tuple;</span><br></pre></td></tr></table></figure>
<p><strong>@weakify(Obj) / @strongify(Obj)</strong><br>用来生成 <code>__weak的self_weak_变量</code> 和 <code>__strong的self指针指向self_weak</code> 用来处理 block 调用中的 循环引用.实现细节可以参考 <a href="http://blog.sunnyxx.com/2014/03/06/rac_1_macros/" target="_blank" rel="external">sunnyxx 大神的 神奇的Macros</a></p>
<h3 id="u5E38_u7528_u64CD_u4F5C"><a href="#u5E38_u7528_u64CD_u4F5C" class="headerlink" title="常用操作"></a>常用操作</h3><p>例子摘自<a href="http://www.jianshu.com/p/e10e5ca413b7" target="_blank" rel="external">最快让你上手ReactiveCocoa之进阶篇</a> 和 <a href="http://ios.jobbole.com/82356/" target="_blank" rel="external">这样好用的ReactiveCocoa,根本停不下来</a>(PS: 如果知道原文地址请告知 :) )</p>
<h5 id="u6620_u5C04"><a href="#u6620_u5C04" class="headerlink" title="映射"></a>映射</h5><ul>
<li>map 将信号的值映射成一个新值</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UITextField</span> *textField= [[<span class="built_in">UITextField</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">30</span>)];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:textField];</span><br><span class="line">    </span><br><span class="line">[[[textField rac_textSignal] map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">@"map 过的值"</span>;</span><br><span class="line">&#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">  <span class="comment">// 处理 map 之后的值</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<ul>
<li>flattenMap 将信号映射成新的信号</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">   NSLog<span class="list">(@<span class="string">"第一步操作"</span>)</span><span class="comment">;</span></span><br><span class="line">   <span class="collection">[subscriber sendNext:@<span class="string">"第二步操作"</span>]</span><span class="comment">;</span></span><br><span class="line">   <span class="collection">[subscriber sendCompleted]</span><span class="comment">;</span></span><br><span class="line">   return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> flattenMap:<span class="comment">^RACStream</span> *<span class="list">(<span class="keyword">NSString*</span> value)</span> <span class="collection">&#123;</span><br><span class="line">   return <span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">       NSLog<span class="list">(@<span class="string">"现在进行的是: %@"</span>,value)</span><span class="comment">;</span></span><br><span class="line">       <span class="collection">[subscriber sendNext:@<span class="string">"操作完毕"</span>]</span><span class="comment">;</span></span><br><span class="line">       <span class="collection">[subscriber sendCompleted]</span><span class="comment">;</span></span><br><span class="line">       return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">   &#125;</span>]</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">   // x = 操作完毕</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="u7EC4_u5408"><a href="#u7EC4_u5408" class="headerlink" title="组合"></a>组合</h4><ul>
<li>concat 按顺序拼接信号,并且有顺序地接收信号</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal <span class="string">createSignal:</span>^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber <span class="string">sendNext:</span>@<span class="string">"我先做完才能做 B"</span>];</span><br><span class="line">   [subscriber sendCompleted];</span><br><span class="line">   <span class="keyword">return</span> nil;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">RACSignal *signalB = [RACSignal <span class="string">createSignal:</span>^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber <span class="string">sendNext:</span>@<span class="string">"我要等 A 做完了才能开始"</span>];</span><br><span class="line">   [subscriber sendCompleted];</span><br><span class="line">   <span class="keyword">return</span> nil;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">[[signalA <span class="string">concat:</span>signalB] <span class="string">subscribeNext:</span>^(id x) &#123;</span><br><span class="line">   <span class="comment">// 输出</span></span><br><span class="line">   <span class="comment">// 我先做完才能做 B</span></span><br><span class="line">   <span class="comment">// 我要等 A 做完了才能开始</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<ul>
<li>then 用于连接多个信号当前一个信号结束,开始下一个信号.</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[<span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">   NSLog<span class="list">(@<span class="string">"第一步"</span>)</span><span class="comment">;</span></span><br><span class="line">   <span class="collection">[subscriber sendCompleted]</span><span class="comment">;</span></span><br><span class="line">   return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> then:<span class="comment">^RACSignal</span> *<span class="collection">&#123;</span><br><span class="line">   return <span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">       NSLog<span class="list">(@<span class="string">"第二步"</span>)</span><span class="comment">;</span></span><br><span class="line">       <span class="collection">[subscriber sendCompleted]</span><span class="comment">;</span></span><br><span class="line">       return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">   &#125;</span>]</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> then:<span class="comment">^RACSignal</span> *<span class="collection">&#123;</span><br><span class="line">   return <span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">       NSLog<span class="list">(@<span class="string">"第三步"</span>)</span><span class="comment">;</span></span><br><span class="line">       <span class="collection">[subscriber sendCompleted]</span><span class="comment">;</span></span><br><span class="line">       return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">   &#125;</span>]</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> subscribeCompleted:<span class="comment">^&#123;</span><br><span class="line">   NSLog(@"第四步");</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>merge 将多个信号合并为一个,任何一个信号发出就会调用</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber sendNext:@<span class="string">"信号一"</span>];</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber sendNext:@<span class="string">"信号二"</span>];</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="string">[[RACSignal merge:@[signalA, signalB]]</span> subscribeNext:^(id x) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<ul>
<li>zipWith 将多个信号合并为一个多个信号发出就会调用,接受的值为一个元组</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal <span class="string">createSignal:</span>^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber <span class="string">sendNext:</span>@<span class="string">"signalA"</span>];</span><br><span class="line">   <span class="keyword">return</span> nil;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">RACSignal *signalB = [RACSignal <span class="string">createSignal:</span>^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber <span class="string">sendNext:</span>@<span class="string">"signalB"</span>];</span><br><span class="line">   <span class="keyword">return</span> nil;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">[[signalA <span class="string">zipWith:</span>signalB] <span class="string">subscribeNext:</span>^(id x) &#123;</span><br><span class="line">   </span><br><span class="line">   NSLog(@<span class="string">"%@"</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<ul>
<li>reduce 把信号发出元组的值聚合成一个值</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal <span class="string">createSignal:</span>^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber <span class="string">sendNext:</span>@<span class="string">"signalA"</span>];</span><br><span class="line">   <span class="keyword">return</span> nil;</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *signalB = [RACSignal <span class="string">createSignal:</span>^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber <span class="string">sendNext:</span>@<span class="string">"signalB"</span>];</span><br><span class="line">   <span class="keyword">return</span> nil;</span><br><span class="line">&#125;];</span><br><span class="line">[[RACSignal <span class="string">combineLatest:</span>@[sugarSignal, waterSignal] <span class="string">reduce:</span>^id (NSString *str1, NSString *str2)&#123;</span><br><span class="line">   <span class="keyword">return</span> [str1 <span class="string">stringByAppendingString:</span>str2];</span><br><span class="line">&#125;] <span class="string">subscribeNext:</span>^(id x) &#123;</span><br><span class="line">	<span class="comment">// 输出 "str1str2"</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="u8FC7_u6EE4"><a href="#u8FC7_u6EE4" class="headerlink" title="过滤"></a>过滤</h4><ul>
<li>filter 过滤信号</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[textField rac_textSignal]</span> filter:<span class="comment">^BOOL</span><span class="list">(<span class="keyword">id</span> value)</span> <span class="collection">&#123;</span><br><span class="line">   return textField.text.length &gt; <span class="number">6</span> ? YES : NO;</span><br><span class="line">&#125;</span>]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">  // 之后当 textField.text 的长度大于六位才会接收到信号</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ignore 忽略完某些值的信</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[textField rac_textSignal]</span> ignore:@<span class="string">"我是被忽略的值"</span>]</span> </span><br><span class="line">subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>distinctUntilChanged 只有当与上一个信号值不同时,才会发出信号</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[textField rac_textSignal]</span> distinctUntilChanged]</span> </span><br><span class="line">subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>take 取 N 次的信号</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *signal = [RACSubject subject];</span><br><span class="line">[[signal <span class="string">take:</span><span class="number">1</span>] <span class="string">subscribeNext:</span>^(id x) &#123;</span><br><span class="line">	<span class="comment">// 只会接受一次信号</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signal <span class="string">sendNext:</span>@<span class="number">1</span>];</span><br><span class="line">[signal <span class="string">sendNext:</span>@<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>takeLast 取最后 N 次的信号,订阅者必须调用完成.</li>
</ul>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *signal = <span class="comment">[RACSubject subject]</span>;</span><br><span class="line"><span class="comment">[<span class="comment">[signal takeLast:1]</span> subscribeNext:^(id x) &#123;</span><br><span class="line">	// 只会接受最后一次信号</span><br><span class="line">&#125;]</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">[signal sendNext:@1]</span>;</span><br><span class="line"><span class="comment">[signal sendNext:@2]</span>;</span><br><span class="line"><span class="comment">[signal sendCompleted]</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>takeUntil 监听信号直到某个信号执行完成</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[[textField rac_textSignal]</span> <span class="tag">takeUntil</span><span class="pseudo">:self</span><span class="class">.rac_willDeallocSignal</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>引用<a href="http://limboy.me/ios/2014/06/06/deep-into-reactivecocoa2.html" target="_blank" rel="external">limboy 大神的一个例子</a><br>它的常用场景之一是处理cell的button的点击事件,比如点击Cell的详情按钮,需要push一个VC,就可以这样:</p>
</blockquote>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[cell.detailButton</span><br><span class="line">    rac_signalForControlEvents:UIControlEventTouchUpInside]</span></span><br><span class="line">    takeUntil:cell.rac_prepareForReuseSignal]</span></span><br><span class="line">    subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">        // generate and push ViewController</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>skip 跳过 N 个信号</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[textField rac_textSignal]</span> skip:1]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>takeUntilBlock:(BOOL (^)(id x)) 对于每个信号的值,运行block,当block返回YES时停止.</li>
<li>takeWhileBlock:(BOOL (^)(id x)) 对于每个信号的值,运行block,当block返回NO时停止.</li>
<li>skipUntilBlock:(BOOL (^)(id x)) 对于每个信号的值,运行block,当block返回YES时停止跳过.</li>
<li>skipWhileBlock:(BOOL (^)(id x)) 对于每个信号的值,运行block,当block返回NO时停止跳过.</li>
</ul>
<h4 id="u79E9_u5E8F"><a href="#u79E9_u5E8F" class="headerlink" title="秩序"></a>秩序</h4><ul>
<li>doNext 执行 Next 之前,会先执行这个Block</li>
<li>doCompleted 执行 sendCompleted 之前,会先执行这个Block</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[<span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">  <span class="collection">[subscriber sendNext:@<span class="number">1</span>]</span><span class="comment">;</span></span><br><span class="line">  <span class="collection">[subscriber sendCompleted]</span><span class="comment">;</span></span><br><span class="line">  return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> doNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">// 执行<span class="collection">[subscriber sendNext:@<span class="number">1</span>]</span><span class="comment">;之前会调用这个Block</span></span><br><span class="line">  NSLog<span class="list">(@<span class="string">"doNext"</span>)</span><span class="comment">;;</span></span><br><span class="line">&#125;</span>]</span> doCompleted:<span class="comment">^&#123;</span><br><span class="line">   // 执行[subscriber sendCompleted];之前会调用这个Block</span><br><span class="line">  NSLog(@"doCompleted");;</span><br><span class="line"></span><br><span class="line">&#125;</span>]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line"></span><br><span class="line">  NSLog<span class="list">(@<span class="string">"%@"</span>,x)</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="u65F6_u95F4"><a href="#u65F6_u95F4" class="headerlink" title="时间"></a>时间</h4><ul>
<li>timeout 超时</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">   return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> timeout:10 onScheduler:<span class="collection">[RACScheduler currentScheduler]</span>]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span> error:^<span class="list">(<span class="keyword">NSError</span> *error)</span> <span class="collection">&#123;</span><br><span class="line">   // 十秒后调用</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>interval 定时</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[RACSignal interval:1 onScheduler:<span class="collection">[RACScheduler currentScheduler]</span>]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>delay 延迟调用 sendNext</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">   <span class="collection">[subscriber sendNext:@<span class="string">"signal"</span>]</span><span class="comment">;</span></span><br><span class="line">   return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> delay: <span class="number">10</span>]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">   // <span class="number">10</span> 秒后接收</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="u91CD_u590D"><a href="#u91CD_u590D" class="headerlink" title="重复"></a>重复</h4><ul>
<li>retry 重试,只要失败,就会重新执行创建信号中的block,直到成功.</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">[[[RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       <span class="keyword">if</span> (i == <span class="number">10</span>) &#123;</span><br><span class="line">           [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@"接收到错误"</span>);</span><br><span class="line">           [subscriber sendError:<span class="literal">nil</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       i++;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] retry] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"></span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<ul>
<li>replay 重放,当一个信号被多次订阅,只发送第一次的数据</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>; </span><br><span class="line">	[subscriber sendNext:@(a)];</span><br><span class="line">	a ++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] replay];</span><br><span class="line">    </span><br><span class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"第一个订阅者%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"第二个订阅者%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个输出都为 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>throttle 节流,当某个信号发送比较频繁时可以隔一段时间获取信号的最新内容</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在十秒内不接受任何信号内容,十秒后获取最后发送的信号内容</span></span><br><span class="line"><span class="attr_selector">[[[RACSubject subject]</span> <span class="tag">throttle</span><span class="pseudo">:10</span>] <span class="tag">subscribeNext</span>:^(id x) &#123;</span><br><span class="line">   </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="u8865_u5145"><a href="#u8865_u5145" class="headerlink" title="补充"></a>补充</h4><p>听了<a href="https://github.com/DeveloperLx" target="_blank" rel="external">DeveloperLx</a>关于 ReactiveCocoa 的分享,记录一下一个优化即时搜索的代码段,很值得学习.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UITextField</span> * textField = [[<span class="built_in">UITextField</span> alloc]init];</span><br><span class="line">textField<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> cyanColor];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:textField];</span><br><span class="line">   </span><br><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line">[textField mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">  @strongify(<span class="keyword">self</span>);</span><br><span class="line">  make<span class="variable">.size</span><span class="variable">.mas_equalTo</span>(<span class="built_in">CGSizeMake</span>(<span class="number">180</span>, <span class="number">40</span>));</span><br><span class="line">  make<span class="variable">.center</span><span class="variable">.equalTo</span>(<span class="keyword">self</span><span class="variable">.view</span>);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//throttle 后面是个时间 表示rac_textSignal发送消息，0.3秒内没有再次发送就会相应，若是0.3内又发送消息了，便会在新的信息处重新计时</span></span><br><span class="line"><span class="comment">//distinctUntilChanged 表示两个消息相同的时候，只会发送一个请求</span></span><br><span class="line"><span class="comment">//ignore 表示如果消息和ignore后面的消息相同，则会忽略掉这条消息，不让其发送</span></span><br><span class="line">[[[[[[textField<span class="variable">.rac_textSignal</span> throttle:<span class="number">0.3</span>] distinctUntilChanged] ignore:<span class="string">@""</span>] map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//  network request</span></span><br><span class="line">      [subscriber sendNext:value];</span><br><span class="line">      [subscriber sendCompleted];</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//  cancel request</span></span><br><span class="line">      &#125;];</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;]switchToLatest] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">  </span><br><span class="line">  LxDBAnyVar(x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>这样做给服务器减小了很多的压力，更是节省了我们大量的代码。 其中我们用map建立了一个新的信号，我们知道textField的改变是一个信号， map就是在这个信号上，又加了一个信号，即signal of signals。<br>订阅者所打印的消息x则是，map发出的信号。我们可以再map中发送新的信号，以及取消信号disposable.<br>当我们用map发送信号的时候，我们则需要使用 switchToLatest这个参数来获取最后一个信号，也就是我们最后所打印的x，就是map最后发错的这个信号。</p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>未完待续</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://broccolii.github.io/2015/12/31/ReactiveCocoa_exploration/" data-id="cinvit7c5000u9v20xyc7a7h7" class="article-share-link">分享到</a><div class="tags"><a href="/tags/ReactiveCocoa/">ReactiveCocoa</a></div><div class="post-nav"><a href="/2016/01/26/UITableView_Optimization/" class="pre">UITableView 性能优化</a><a href="/2015/11/06/iOS9_3D_Touch/" class="next">iOS9 中的 3D Touch</a></div><div id="disqus_thread"><script>var disqus_shortname = 'broccoliii';
var disqus_identifier = '2015/12/31/ReactiveCocoa_exploration/';
var disqus_title = 'ReactiveCocoa 整理';
var disqus_url = 'http://broccolii.github.io/2015/12/31/ReactiveCocoa_exploration/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//broccoliii.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><input placeholder="Search" type="text" class="st-default-search-input"/></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Swift/" style="font-size: 15px;">Swift</a> <a href="/tags/Thread/" style="font-size: 15px;">Thread</a> <a href="/tags/Database/" style="font-size: 15px;">Database</a> <a href="/tags/RunLoop/" style="font-size: 15px;">RunLoop</a> <a href="/tags/CoreSpotlight/" style="font-size: 15px;">CoreSpotlight</a> <a href="/tags/3DTouch/" style="font-size: 15px;">3DTouch</a> <a href="/tags/Chrome/" style="font-size: 15px;">Chrome</a> <a href="/tags/UITableView/" style="font-size: 15px;">UITableView</a> <a href="/tags/Debug/" style="font-size: 15px;">Debug</a> <a href="/tags/ReactiveCocoa/" style="font-size: 15px;">ReactiveCocoa</a> <a href="/tags/Objective-C/" style="font-size: 15px;">Objective-C</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/Block/" style="font-size: 15px;">Block</a> <a href="/tags/Alamofire-Swift/" style="font-size: 15px;">Alamofire Swift</a> <a href="/tags/GCD/" style="font-size: 15px;">GCD</a> <a href="/tags/CocoaPods/" style="font-size: 15px;">CocoaPods</a> <a href="/tags/Alfred/" style="font-size: 15px;">Alfred</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/GCD_dispatch_semaphore/">GCD 中的 dispatch_semaphore</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/03/Learning_Swift_from_Alamofire_source/">从 Alamofire 源码学习 Swift</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/16/Swift_algorithm/">Swift 中简单的算法题</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/12/iOS_debug/">iOS 开发中的调试小技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/03/Objective-C_initialize_load/">Objective-C 中的 load 和 initialize</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/22/Autolayout_flow/">Auto Layout 绘制流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/16/iOS_database/">Core Data, FMDB, Realm 性能对比</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/02/Alfred_3_config/">Alfred 2 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/04/CocoaPods_private_library/">使用 CocoaPods 管理私有库</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/26/UITableView_Optimization/">UITableView 性能优化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//broccoliii.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://qbeenslee.com/" title="qbeenslee" target="_blank">qbeenslee</a><ul></ul><a href="http://wuqiuhao.github.io/" title="qiuhao" target="_blank">qiuhao</a><ul></ul><a href="http://zeeyang.com/" title="zeeyang" target="_blank">zeeyang</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">一朵西兰花.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

_st('install','UKkneeeyb79HvjysWVot','2.0.0');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?64b81a3596d6c5ec76f245076ec9bd2a";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>