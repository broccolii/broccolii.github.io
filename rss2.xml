<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[一朵西兰花]]></title>
    <link>http://broccolii.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[不求深刻,但求简单.]]></description>
    <pubDate>Wed, 16 Mar 2016 06:40:57 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[Core Data, FMDB, Realm 性能对比]]></title>
      <link>http://broccolii.github.io/2016/03/16/iOS_database/</link>
      <guid>http://broccolii.github.io/2016/03/16/iOS_database/</guid>
      <pubDate>Tue, 15 Mar 2016 18:26:52 GMT</pubDate>
      <description>
      <![CDATA[<h3 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h3><p>iOS 持久化其实也没多少选择.面试题经常会被问到, 但是无非也就下面几种:文件写入沙盒, <code>]]>
      </description>
      <content:encoded><![CDATA[<h3 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h3><p>iOS 持久化其实也没多少选择.面试题经常会被问到, 但是无非也就下面几种:文件写入沙盒, <code>NSUserDefaults</code>, <code>NSKeyedArchiver</code>(归档), <code>SQLite 3</code>, 基于 <code>SQLite</code> 的一些数据库封装. 最近工作需要评估一下 iOS 常用的几种数据库的性能, 所以有了这篇文章.</p>
<h3 id="u4ECB_u7ECD"><a href="#u4ECB_u7ECD" class="headerlink" title="介绍"></a>介绍</h3><p><strong>FMDB</strong><br>直接在 iOS 中使用原生的 SQLite API 时, 需要使用大量的 C 语言.这样体验并不友好,所以出现了 <a href="https://github.com/ccgus/fmdb" target="_blank" rel="external">FMDB</a> 这样使用 <code>Objective-C</code> 封装的 SQLite API 的数据库框架. 这样使 <code>SQLite</code> 操作更简单易懂.并且它对于多线程的并发操作进行了处理,所以是线程安全的.</p>
<p><strong>Realm</strong><br><a href="https://realm.io/cn/" target="_blank" rel="external">Realm</a> 是由 <code>Y Combinator</code> 公司孵化的一款支持运行在手机、平板和可穿戴设备上的嵌入式数据库(旨在取代CoreData和Sqlite). Realm并不是基于Core Data,也不是基于 SQLite 所构建 ORM 的.它拥有自己的数据库存储引擎,可以高效且快速地完成数据库的构建操作。 Realm 支持iOS、OS X（Objective‑C和Swift）以及Android.Realm文件可以跨平台共享.Realm 还提供了<a href="https://realm.io/cn/docs/objc/latest/" target="_blank" rel="external">中文文档</a>.</p>
<p><strong>Core Data</strong><br><code>Core Data</code> 是一个模型层的技术. Core Data 本身既不是数据库也不是数据库访问框架.相反,Core Data是一个完整的数据模型解决方案.我简单理解为对持久层的封装，使得我们可以通过可视化建立数据模型,简化数据存取. Core Data不是一个 O/RM, 也不像 FMDB 是一个 SQL wrapper.</p>
<h3 id="u4F7F_u7528_u65B9_u6CD5"><a href="#u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="FMDB"><a href="#FMDB" class="headerlink" title="FMDB"></a>FMDB</h4><p><strong>集成</strong>:推荐使用Cocoapods进行安装，在Podfile中添加pod ‘FMDB’即可.</p>
<p>FMDB有三个主要的类</p>
<ul>
<li>FMDatabase: FMDatabase 对象就代表一个单独的SQLite数据库,用来执行 SQLite 语句.</li>
<li>FMResultSet: 存放 FMDatabase 执行查询后的结果集.</li>
<li>FMDatabaseQueue: 用于在多线程中执行多个查询或更新，它是线程安全的.</li>
</ul>
<p><strong>创建</strong>: create database: 在沙盒内创建一个 <code>FMDBModel.sqlite</code> 文件.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString* dbPath = [[NSString <span class="string">stringWithFormat:</span>@<span class="string">"%@"</span>, [[NSFileManager defaultManager] <span class="string">URLForDirectory:</span>NSDocumentDirectory <span class="string">inDomain:</span>NSUserDomainMask <span class="string">appropriateForURL:</span>nil <span class="string">create:</span>YES <span class="string">error:</span>nil]] <span class="string">stringByAppendingPathComponent:</span>@<span class="string">"FMDBModel.sqlite"</span>];</span><br><span class="line"></span><br><span class="line">FMDatabase* database = [[FMDatabase alloc] <span class="string">initWithPath:</span>dbPath];</span><br></pre></td></tr></table></figure>
<p><code>dbPath</code> 的路径有三种情况:</p>
<ol>
<li>具体文件路径: 如果不存在会自动创建.</li>
<li>@””: 会在临时目录创建一个空的数据库,当 FMDatabase 连接关闭时,数据库被删除.</li>
<li>nil: 会创建一个内存中临时数据库，当 FMDatabase 连接关闭时,数据库会被销毁.</li>
</ol>
<p><strong>查</strong>: 查询 ID &lt; 1000 的所有数据</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FMResultSet *resultSet = [db <span class="string">executeQuery:</span>[NSString <span class="string">stringWithFormat:</span>@<span class="string">"SELECT * FROM t_messageModel WHERE ID &lt; 1000"</span>]];</span><br></pre></td></tr></table></figure>
<p><strong>增</strong>,<strong>删</strong>,<strong>改</strong> : 除了 <code>executeQuery(查询)</code> 外所有操作都是 <code>executeUpdate(更新)</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[db executeUpdate: @"<span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_messageModel (sender_id, msg_type, sender_avatar, sender_nickname, msg_id, <span class="keyword">content</span>, operate_time, create_time, conversation_id) <span class="keyword">VALUES</span> (?,?,?,?,?,?,?,?,?)<span class="string">"</span></span></span><br></pre></td></tr></table></figure>
<p>SQLite 本身支持事务处理, FMDB作为sqlite的上层封装也对事务进行了支持.</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">[<span class="keyword">db</span> open]<span class="comment">;</span></span><br><span class="line"><span class="list">[<span class="keyword">db</span> beginTransaction]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">BOOL isRollBack = NO<span class="comment">;</span></span><br><span class="line">@try &#123;</span><br><span class="line">   for <span class="list">(<span class="keyword">FMDBMessageModel</span> *model in array)</span> &#123;</span><br><span class="line">       BOOL isInsertSucceed = <span class="list">[<span class="keyword">db</span> executeUpdate:@<span class="string">"INSERT INTO t_messageModel (sender_id, msg_type, sender_avatar, sender_nickname, msg_id, content, operate_time, create_time, conversation_id) VALUES (?,?,?,?,?,?,?,?,?)"</span>,</span><br><span class="line">                               model.sender_id,</span><br><span class="line">                               model.msg_type,</span><br><span class="line">                               model.sender_avatar,</span><br><span class="line">                               model.sender_nickname,</span><br><span class="line">                               @<span class="list">(<span class="keyword">model.msg_id</span>)</span>,</span><br><span class="line">                               model.content,</span><br><span class="line">                               @<span class="list">(<span class="keyword">model.operate_time</span>)</span>,</span><br><span class="line">                               @<span class="list">(<span class="keyword">model.create_time</span>)</span>,</span><br><span class="line">                               model.conversation_id]<span class="comment">;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">@catch <span class="list">(<span class="keyword">NSException</span> *exception)</span> &#123;</span><br><span class="line">   isRollBack = YES<span class="comment">;</span></span><br><span class="line">   <span class="list">[<span class="keyword">db</span> rollback]<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">@finally &#123;</span><br><span class="line">   if <span class="list">(<span class="keyword">!isRollBack</span>)</span> &#123;</span><br><span class="line">       <span class="list">[<span class="keyword">db</span> commit]<span class="comment">;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="list">[<span class="keyword">db</span> close]<span class="comment">;</span></span></span></span></span></span></span></span><br></pre></td></tr></table></figure>
<h4 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h4><p><a href="https://realm.io/cn/docs/objc/latest/#section" target="_blank" rel="external">官方文档</a><br><strong>集成</strong>: 推荐使用Cocoapods进行安装，在Podfile中添加pod ‘Realm’ 即可.<br><strong>辅助工具</strong><br>1、Realm Browser<br>Realm官方非常贴心的向开发者提供了一个用于查看和编辑 Realm 数据的工具 Realm Browser.<br><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/iOS_database/RealmBrowser.png" alt=""><br>2、Xcode Plugin<br>在Realm中使用到最多的是Realm Model(继承自RLMObject的类，后面有介绍)。官方提供了一个Xcode的插件让我们在创建模型变得非常轻松<br><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/iOS_database/RealmPlugin.png" alt=""><br>直接通过 <code>Alcatraz</code>, 搜索 <code>RealmPlugin</code> 直接安装.</p>
<p><strong>创建</strong>: 和 <code>FMDB</code> 一样,有三种方式创建数据库.一种是存储在默认路径下的数据库,一种是我们可以自己指定数据库文件的存储路径和只读属性,另外还可以使用内存数据库.</p>
<ul>
<li>默认Realm数据库</li>
</ul>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RLMRealm *realm = <span class="string">[RLMRealm defaultRealm]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>自定义Realm数据库</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *docPath = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</span><br><span class="line"><span class="built_in">NSString</span> *dbPath = [docPath stringByAppendingPathComponent:<span class="string">@"db/db.realm"</span>];</span><br><span class="line">RLMRealm *realm = [RLMRealm realmWithPath:dbPath];</span><br><span class="line"><span class="comment">// 或者 只读类型</span></span><br><span class="line">RLMRealm *realm = [RLMRealm realmWithPath:dbPath readOnly:<span class="literal">YES</span> error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>内存数据库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Realm *realm = [RLMRealm <span class="keyword">in</span>MemoryRealmWithIdentifier:@<span class="string">"memoryDatabase"</span>];</span><br></pre></td></tr></table></figure>
<p><strong>Model</strong><br>Realm 数据模型是基于标准 Objective‑C 类来进行定义的，使用属性来完成模型的具体定义。通过简单的继承 RLMObject 或者一个已经存在的模型类，您就可以创建一个新的 Realm 数据模型对象。Realm 模型对象在形式上基本上与其他 Objective‑C 对象相同.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主键</span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)primaryKey &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要添加索引的属性</span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)indexedProperties &#123;&#125;</span><br><span class="line"><span class="comment">//默认属性值</span></span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)defaultPropertyValues &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//忽略的字段</span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)ignoredProperties &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>.m</code> 文件中, Realm 提供了以上方法供对属性进行自定义.</p>
<p><strong>数据增删改查</strong><br><code>对对象的所有更改（添加，修改和删除）都必须通过写入事务(transaction)完成。</code><br>1) <em>增</em>:</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RLMRealm *realm = <span class="string">[RLMRealm defaultRealm]</span>;</span><br><span class="line"><span class="string">[realm beginWriteTransaction]</span>;</span><br><span class="line"><span class="string">[realm addObject:model]</span>;</span><br><span class="line"><span class="string">[realm commitWriteTransaction]</span>;</span><br></pre></td></tr></table></figure>
<p>2) <em>删</em></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[realm beginWriteTransaction]</span>;</span><br><span class="line"><span class="attr_selector">[realm deleteObject:model]</span>;</span><br><span class="line"><span class="comment">// 或者 删除全部</span></span><br><span class="line"><span class="attr_selector">[realm deleteAllObjects]</span>;</span><br><span class="line"><span class="attr_selector">[realm commitWriteTransaction]</span>;</span><br></pre></td></tr></table></figure>
<p>3) <em>改</em><br>Realm 提供了一系列用以更新数据的方式，这些方式都有着各自所适应的情景。请选择最符合您当前需求的方式来使用：</p>
<p>3.1 内容直接更新<br>您可以在写入事务中通过设置某个对象的属性从而完成对象的更新操作。</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[realm beginWriteTransaction]</span>;</span><br><span class="line">model.name = @<span class="string">"broccoliii"</span>;</span><br><span class="line"><span class="string">[realm commitWriteTransaction]</span>;</span><br></pre></td></tr></table></figure>
<p>3.2 通过主键更新<br>如果您的数据模型中设置了主键的话，那么您可以使用 <code>+[RLMObject createOrUpdateInRealm:withValue:]</code> 来更新对象，或者当对象不存在时插入新的对象。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">[realm beginWriteTransaction]</span><span class="comment">;</span></span><br><span class="line"><span class="title">[Model createOrUpdateInRealm:realm withValue:model]</span><span class="comment">;</span></span><br><span class="line"><span class="title">[realm commitWriteTransaction]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>3.3 通过 <code>KVC</code> 更新</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RLMResults *models = [RealmMessageModel <span class="literal">all</span>Objects];</span><br><span class="line">[<span class="literal">self</span>.mananger transactionWithBlock:^&#123;</span><br><span class="line">   [models <span class="built_in">set</span>Value:@<span class="string">"broccoliii"</span> <span class="keyword">for</span>KeyPath:@<span class="string">"nickname"</span>];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>4) <em>查</em></p>
<p>4.1 查询全部数据</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">RLMResults *models</span> = [RealmModel allObjects];</span><br><span class="line"><span class="comment">// 或者 指定数据库</span></span><br><span class="line"><span class="constant">RLMResults *models</span> = [RealmModel allObjectsInRealm:realm];</span><br></pre></td></tr></table></figure>
<p>4.2 条件查询</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RLMResults *results = [RealmModel <span class="string">objectsWhere:</span>@<span class="string">"nickname = 'broccoliii'"</span>];</span><br><span class="line"><span class="comment">// 或者使用谓词</span></span><br><span class="line">NSPredicate *predicate = [NSPredicate <span class="string">predicateWithFormat:</span>@<span class="string">"nickname = '%@'"</span>, @<span class="string">"broccoliii"</span>];</span><br><span class="line">RLMResults *results = [RealmModel <span class="string">objectsWithPredicate:</span>predicate];</span><br></pre></td></tr></table></figure>
<p>4.3 条件排序<br>筛选出来的结果按照num字段进行递增排序：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RLMResults *results = [[RealmModel <span class="string">objectsWhere:</span>@<span class="string">"nickname = 'broccoliii'"</span>] <span class="string">sortedResultsUsingProperty:</span>@<span class="string">"ID"</span> <span class="string">ascending:</span>YES];</span><br></pre></td></tr></table></figure>
<p>4.4 链式查询<br>在 <code>nickname</code> 是 <code>broccoliii</code> 的结果中查询 <code>age</code> 为 23 的结果集.</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RLMResults <span class="keyword">*</span>nameResults = [RealmModel objectsWhere:<span class="comment">@"nickname = 'broccoliii'"];</span></span><br><span class="line">RLMResults <span class="keyword">*</span>results = [nameResults objectsWhere:<span class="comment">@"age = 23"];</span></span><br></pre></td></tr></table></figure>
<h4 id="Core_Data"><a href="#Core_Data" class="headerlink" title="Core Data"></a>Core Data</h4><p>新建一个 Core Data 工程, 在 <code>Choose a template for your new progect</code> 时, 勾选 <code>Use Core Data</code>.<br><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/iOS_database/Use_Core_Data.png" alt=""></p>
<p>项目建立后会发现 Frameworks 中已经有了 CoreData.framework 一项，并且还多了一个<em>**</em>.xcdatamodeld 文件，该文件定义了数据模型结构，你可以使用XCode内置的可视化建模工具进行构建。点开它你会发现左侧有三项：<code>Entities</code>，<code>Fetch Request</code>、<code>Configurations</code>。<em>Entities</em>: 可以简单的将 Entity 理解为数据库中的一张表. 点击下方 <code>Add Entity</code> 新增 <code>Entities</code>. 表中 <code>Attributes</code> 相当于一张表的列属性,可以设置其数据类型，默认值，最大最小值等，类似数据库可视化建表. <em>Fetch Request</em> 相当于 SQL 查询语句的包装类, 用 <code>NSFetchRequest</code> 封装一次数据请求, 通过 <code>Fetch Request</code> 将 <code>NSFetchRequest</code> 作为模板存储在被管理对象模型. </p>
<p>因为我们在工程创建时, 勾选了 <code>Use Core Data</code>, 在 AppDelegate.h 中多了几个 <code>property</code>, <code>method</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;CoreData/CoreData.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AppDelegate</span> : <span class="title">UIResponder</span> &lt;<span class="title">UIApplicationDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIWindow</span> *window;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSManagedObjectContext</span> *managedObjectContext;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSManagedObjectModel</span> *managedObjectModel;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSPersistentStoreCoordinator</span> *persistentStoreCoordinator;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)saveContext;</span><br><span class="line">- (<span class="built_in">NSURL</span> *)applicationDocumentsDirectory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><code>NSManagedObjectModel</code> 可以把它看做为一个 Core Data 的 schema。生成这个类的来源就是在 xCode 里的.xcdatamodeld文件，我们可以可视化的对这个文件进行操作，实际上这个文件也就相当于数据库的 schema，这个文件编译后就是.momd或.mom文件<br><code>NSPersistentStoreCoordinator</code> 是一个位于本地存储文件与缓存层(NSManagedObjectContext)之间的一个持久化层，他是真实操作数据库本地文件。<br><code>NSManagedObjectContext</code> 是一个被管理数据的上下文，他实际上是对你所有数据库操作的一个缓存层，把你所有的操作都先缓存起来避免大量磁盘 IO 造成不流畅，你在操作完数据库后调用其save方法，就可以把你的数据库操作提交给持久化层(NSPersistentStoreCoordinator)，由持久化层一次性写入数据库文件。</p>
<p><strong>NSManagedObjectContext 创建</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)configureContext &#123;</span><br><span class="line">    _context = [[<span class="built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="built_in">NSPrivateQueueConcurrencyType</span>];</span><br><span class="line">    <span class="built_in">NSPersistentStoreCoordinator</span> *store = [[<span class="built_in">NSPersistentStoreCoordinator</span> alloc] initWithManagedObjectModel:[<span class="built_in">NSManagedObjectModel</span> mergedModelFromBundles:<span class="literal">nil</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *sqlitePath = [[<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject] stringByAppendingPathComponent:<span class="string">@"t_CoreDataMessageModel.sqlite"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    [store addPersistentStoreWithType:<span class="built_in">NSSQLiteStoreType</span> configuration:<span class="literal">nil</span> URL:[<span class="built_in">NSURL</span> fileURLWithPath:sqlitePath] options:<span class="literal">nil</span> error:&amp;error];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,error);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _context<span class="variable">.persistentStoreCoordinator</span> = store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>数据增删改查</strong><br>1) <em>增</em></p>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="component">- (void)insert:(CoreDataMessageModel *)model &#123;</span><br><span class="line">    CoreDataMessageModel *message = [NSEntityDescription insertNewObjectForEntityForName:@"CoreDataMessageModel" inManagedObjectContext:_context];</span><br><span class="line">    </span><br><span class="line">    message<span class="string">.sender_id</span> = model<span class="string">.sender_id</span>;</span><br><span class="line">    message<span class="string">.msg_type</span> = model<span class="string">.msg_type</span>;</span><br><span class="line">    message<span class="string">.sender_avatar</span> = model<span class="string">.sender_avatar</span>;</span><br><span class="line">    message<span class="string">.sender_nickname</span> = model<span class="string">.sender_nickname</span>;</span><br><span class="line">    message<span class="string">.msg_id</span> = model<span class="string">.msg_id</span>;</span><br><span class="line">    message<span class="string">.content</span> = model<span class="string">.content</span>;</span><br><span class="line">    message<span class="string">.operate_time</span> = model<span class="string">.operate_time</span>;</span><br><span class="line">    message<span class="string">.create_time</span> = model<span class="string">.create_time</span>;</span><br><span class="line">    message<span class="string">.conversation_id</span> = model<span class="string">.conversation_id</span>;</span><br><span class="line">    </span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    [_context save:&amp;error];</span><br><span class="line">    </span><br><span class="line">    if (error) &#123;</span><br><span class="line">        NSLog(@"%@",error);</span><br><span class="line">    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2) <em>删</em></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>)deleteMultiple &#123;</span><br><span class="line">    NSFetchRequest *request = [NSFetchRequest <span class="string">fetchRequestWithEntityName:</span>@<span class="string">"CoreDataMessageModel"</span>];</span><br><span class="line">    </span><br><span class="line">    request.predicate = [NSPredicate <span class="string">predicateWithFormat:</span>@<span class="string">"msg_id &gt; %@"</span>,@<span class="string">"0"</span>];</span><br><span class="line">    </span><br><span class="line">    NSArray *resultSet =  [_context <span class="string">executeFetchRequest:</span>request <span class="string">error:</span>nil];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (CoreDataMessageModel *message <span class="keyword">in</span> resultSet) &#123;</span><br><span class="line">        [_context <span class="string">deleteObject:</span>message];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [_context <span class="string">save:</span>nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3) <em>改</em></p>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="component">- (void)updateSingle:(CoreDataMessageModel *)model &#123;</span><br><span class="line">    NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"CoreDataMessageModel"];</span><br><span class="line">    request<span class="string">.predicate</span> = [NSPredicate predicateWithFormat:@"msg_id = %@",model<span class="string">.msg_id]</span>;</span><br><span class="line">    </span><br><span class="line">    NSArray *resultSet = [_context executeFetchRequest:request error:nil];</span><br><span class="line">    </span><br><span class="line">    for (CoreDataMessageModel *message in resultSet) &#123;</span><br><span class="line">        message<span class="string">.sender_id</span> = model<span class="string">.sender_id</span>;</span><br><span class="line">        message<span class="string">.msg_type</span> = model<span class="string">.msg_type</span>;</span><br><span class="line">        message<span class="string">.sender_avatar</span> = model<span class="string">.sender_avatar</span>;</span><br><span class="line">        message<span class="string">.sender_nickname</span> = model<span class="string">.sender_nickname</span>;</span><br><span class="line">        message<span class="string">.msg_id</span> = model<span class="string">.msg_id</span>;</span><br><span class="line">        message<span class="string">.content</span> = model<span class="string">.content</span>;</span><br><span class="line">        message<span class="string">.operate_time</span> = model<span class="string">.operate_time</span>;</span><br><span class="line">        message<span class="string">.create_time</span> = model<span class="string">.create_time</span>;</span><br><span class="line">        message<span class="string">.conversation_id</span> = model<span class="string">.conversation_id</span>;</span><br><span class="line">    &#125;</span></span><br><span class="line">    </span><br><span class="line">    [_context save:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4) <em>查</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)selectSingle &#123;</span><br><span class="line">    <span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"CoreDataMessageModel"</span>];</span><br><span class="line">    </span><br><span class="line">    request<span class="variable">.predicate</span> = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"msg_id &lt; %@"</span>,<span class="string">@"10000"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [_context executeFetchRequest:request error:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u6027_u80FD_u6BD4_u8F83_28_u7A0D_u540E_u6DFB_u52A0_u56FE_u8868_29"><a href="#u6027_u80FD_u6BD4_u8F83_28_u7A0D_u540E_u6DFB_u52A0_u56FE_u8868_29" class="headerlink" title="性能比较(稍后添加图表)"></a>性能比较(稍后添加图表)</h3><p>循环插入10000次，每次插入一条数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FMDB         		<span class="number">110782</span> ms;</span><br><span class="line">Realm         		<span class="number">65983</span> ms;</span><br><span class="line">CoreData        	<span class="number">74987</span> ms;</span><br></pre></td></tr></table></figure>
<p>批量插入10000条数据：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FMDB         		834 ms<span class="comment">;</span></span><br><span class="line">Realm         		446 ms<span class="comment">;</span></span><br><span class="line">CoreData        	不支持批量操作<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>循环更新10000次，每次更新一条数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FMDB         		<span class="number">898</span> ms;</span><br><span class="line">Realm         		<span class="number">35899</span> ms;</span><br><span class="line">CoreData        	<span class="number">16483</span> ms;</span><br></pre></td></tr></table></figure>
<p>批量更新10000条数据为：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FMDB         		135 ms<span class="comment">;</span></span><br><span class="line">Realm         		47 ms<span class="comment">;</span></span><br><span class="line">CoreData        	不支持批量操作<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>循环查询10000条数据，每次查询一条数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FMDB         		<span class="number">457</span> ms;</span><br><span class="line">Realm         		<span class="number">564</span> ms;</span><br><span class="line">CoreData        	<span class="number">55</span> ms;</span><br></pre></td></tr></table></figure>
<p>批量查询10000条数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FMDB         		<span class="number">0.186</span> ms;</span><br><span class="line">Realm         		<span class="number">0.2</span> ms;</span><br><span class="line">CoreData        	<span class="number">80</span> ms;</span><br></pre></td></tr></table></figure>
<p>注释: CoreData 在 iOS 8 才开始支持批量操作(批量更新(Bench Update) <code>NSBatchUpdateRequest</code>)</p>
<h3 id="App__u4F7F_u7528"><a href="#App__u4F7F_u7528" class="headerlink" title="App 使用"></a>App 使用</h3><p>多看阅读,手机淘宝,手机 QQ,微博, iOS 中的 News 使用了 FMDB.</p>
<h3 id="IM__u7684_u9700_u6C42"><a href="#IM__u7684_u9700_u6C42" class="headerlink" title="IM 的需求"></a>IM 的需求</h3><p>IM 中使用数据库主要的需求是: 大量的单次写入一条数据, 小批量的读取数据以及小批量的写入.</p>
<h3 id="u5404_u81EA_u4F18_u7F3A_u70B9"><a href="#u5404_u81EA_u4F18_u7F3A_u70B9" class="headerlink" title="各自优缺点"></a>各自优缺点</h3><p><strong>FMDB</strong></p>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>对多线程的并发操作进行处理，所以是线程安全的,FMDB是轻量级的框架，使用灵活。</td>
<td>不支持 ORM 需要手写 SQLite 语句</td>
</tr>
</tbody>
</table>
<p><strong>Realm</strong></p>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>入门门槛低,支持 NSPredicate, 支持 ORM</td>
<td>关联关系弱, 强制内省容错机制导致存储文件不断变大, 没有细粒化通知,增加包体积</td>
</tr>
</tbody>
</table>
<p><strong>Core Data</strong></p>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>系统自带, 官方支持; 强大的关联关系; 精细化的通知</td>
<td>入门门槛高; 不支持批量操作</td>
</tr>
</tbody>
</table>
<h3 id="u5F15_u7528"><a href="#u5F15_u7528" class="headerlink" title="引用"></a>引用</h3><p><a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/" target="_blank" rel="external">yulingtianxia’s blog</a><br><a href="https://realm.io/cn/docs/objc/latest/#section" target="_blank" rel="external">realm 官网</a><br><a href="http://iiiyu.com/2016/01/19/CoreData-VS-Realm/" target="_blank" rel="external">CoreData VS Realm</a></p>
]]></content:encoded>
      <comments>http://broccolii.github.io/2016/03/16/iOS_database/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[使用 CocoaPods 管理私有库]]></title>
      <link>http://broccolii.github.io/2016/02/04/CocoaPods_private_library/</link>
      <guid>http://broccolii.github.io/2016/02/04/CocoaPods_private_library/</guid>
      <pubDate>Thu, 04 Feb 2016 04:52:39 GMT</pubDate>
      <description>
      <![CDATA[<h3 id="u914D_u7F6E_-podspec__u6587_u4EF6"><a href="#u914D_u7F6E_-podspec__u6587_u4EF6" class="headerlink" title="配置 .podspec 文件"></a>配置 .po]]>
      </description>
      <content:encoded><![CDATA[<h3 id="u914D_u7F6E_-podspec__u6587_u4EF6"><a href="#u914D_u7F6E_-podspec__u6587_u4EF6" class="headerlink" title="配置 .podspec 文件"></a>配置 .podspec 文件</h3><h5 id="1-__u521B_u5EFA_-podspec__u6587_u4EF6"><a href="#1-__u521B_u5EFA_-podspec__u6587_u4EF6" class="headerlink" title="1. 创建 .podspec 文件"></a>1. 创建 .podspec 文件</h5><p>首先在终端运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod spec create &lt;name&gt;</span><br></pre></td></tr></table></figure>
<p>创建一个 <code>&lt;name&gt;.podspec</code> 文件,创建的文件是初始化模板,不过我们并不需要用到那么多配置.<br>如果有不清楚的地方可以在<a href="https://guides.cocoapods.org/making/specs-and-specs-repo.html" target="_blank" rel="external">CocoaPods 官网</a>查看.下面是我修改过的</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">Pod:</span><span class="symbol">:Spec</span>.new <span class="keyword">do</span> |s|</span><br><span class="line"></span><br><span class="line">  s.name         = <span class="string">"PrivateLibrary"</span></span><br><span class="line">  s.version      = <span class="string">"0.0.1"</span>                  <span class="comment">#版本号</span></span><br><span class="line">  s.summary      = <span class="string">"私有库的描述"</span></span><br><span class="line"></span><br><span class="line">  s.description  = &lt;&lt;-<span class="constant">DESC</span></span><br><span class="line">                   私有库的描述</span><br><span class="line">                   <span class="constant">DESC</span></span><br><span class="line"></span><br><span class="line">  s.homepage     = <span class="string">"https://github.com/broccolii/blog_demo_PrivateLibrary"</span></span><br><span class="line">  s.license      = &#123; <span class="symbol">:type</span> =&gt; <span class="string">"MIT"</span>, <span class="symbol">:file</span> =&gt; <span class="string">"LICENSE"</span> &#125;</span><br><span class="line">  s.author       = &#123; <span class="string">"broccoliii"</span> =&gt; <span class="string">"broccoliii@163.com"</span> &#125;</span><br><span class="line">  s.platform     = <span class="symbol">:ios</span>, <span class="string">"8.0"</span></span><br><span class="line">  s.source       = &#123; <span class="symbol">:git</span> =&gt; <span class="string">"https://github.com/broccolii/blog_demo_PrivateLibrary.git"</span>, <span class="symbol">:tag</span> =&gt; <span class="string">"0.0.1"</span> &#125;</span><br><span class="line">  s.source_files  = <span class="string">"SourceCode/*"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果私有库中使用了 系统系统的 Framework 可以在这里添加 </span></span><br><span class="line">  <span class="comment"># s.framework  = "SomeFramework" </span></span><br><span class="line">  <span class="comment"># s.frameworks = "SomeFramework", "AnotherFramework"</span></span><br><span class="line"></span><br><span class="line">  s.requires_arc = <span class="keyword">true</span> <span class="comment">#开启 ARC</span></span><br><span class="line">  <span class="comment"># s.dependency "&lt;library name&gt;", "~&gt; &lt;version code&gt;" #这里可以添加其他的一些第三方库</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>如果你只需要导入一部分文件可以试一下 <code>subspec</code>, <a href="https://guides.cocoapods.org/syntax/podspec.html#subspec" target="_blank" rel="external">官网教程</a>. 这里需要注意的地方是:如果主题部分添加的依赖库(dependency).可以使用 <code>default_subspec</code> 处理.</p>
<h5 id="2-__u9A8C_u8BC1_-podspec"><a href="#2-__u9A8C_u8BC1_-podspec" class="headerlink" title="2. 验证 .podspec"></a>2. 验证 .podspec</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint &lt;name.podspec&gt;</span><br></pre></td></tr></table></figure>
<p>根据提示改掉 <code>ERROR</code>,直到 <code>pass</code></p>
<h3 id="u5EFA_u7ACB_spec_repository_28_u79C1_u6709_u4E2D_u5FC3_u4ED3_u5E93_29"><a href="#u5EFA_u7ACB_spec_repository_28_u79C1_u6709_u4E2D_u5FC3_u4ED3_u5E93_29" class="headerlink" title="建立 spec repository(私有中心仓库)"></a>建立 spec repository(私有中心仓库)</h3><p>文件结构如下,如果有不太明白的,可以查看<a href="https://github.com/broccolii/blog_demo_Specs" target="_blank" rel="external">blog_demo_Specs</a></p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── Specs  </span><br><span class="line">    └── <span class="string">[LibraryName]</span>  </span><br><span class="line">        └── <span class="string">[VERSION_CODE]</span>  </span><br><span class="line">            └── <span class="string">[LibraryName.podspec]</span></span><br></pre></td></tr></table></figure>
<h3 id="u4FEE_u6539_podfile"><a href="#u4FEE_u6539_podfile" class="headerlink" title="修改 podfile"></a>修改 podfile</h3><p>修改 podfile </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> <span class="string">'https://github.com/broccolii/blog_demo_PrivateLibrary.git'</span></span><br><span class="line">pod <span class="string">'LibraryName'</span></span><br></pre></td></tr></table></figure>
<p>接着</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="keyword">install</span></span><br></pre></td></tr></table></figure>
<p><em>PS:</em> 如果想把自己写的库支持 CocoaPods,可以看一下<a href="http://yulingtianxia.com/blog/2014/05/26/publish-your-pods-on-cocoapods-with-trunk/" target="_blank" rel="external">Publish Your Pods on CocoaPods with Trunk</a></p>
]]></content:encoded>
      <comments>http://broccolii.github.io/2016/02/04/CocoaPods_private_library/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[UITableView 性能优化]]></title>
      <link>http://broccolii.github.io/2016/01/26/UITableView_Optimization/</link>
      <guid>http://broccolii.github.io/2016/01/26/UITableView_Optimization/</guid>
      <pubDate>Tue, 26 Jan 2016 15:31:22 GMT</pubDate>
      <description>
      <![CDATA[<p>最近面试问到关于 UITableView 的优化,感觉自己回答的不是特别好,刚好项目上线需要优化一部分代码.所以在网上查阅了大量 blog,总结了一些关于 UITableView 实用的优化技巧.</p>
<h3 id="UITableView__u91CD_u7528_u]]>
      </description>
      <content:encoded><![CDATA[<p>最近面试问到关于 UITableView 的优化,感觉自己回答的不是特别好,刚好项目上线需要优化一部分代码.所以在网上查阅了大量 blog,总结了一些关于 UITableView 实用的优化技巧.</p>
<h3 id="UITableView__u91CD_u7528_u673A_u5236"><a href="#UITableView__u91CD_u7528_u673A_u5236" class="headerlink" title="UITableView 重用机制"></a>UITableView 重用机制</h3><p>UITableView 最核心的部分就是 UITableViewCell 的重用机制(初学者必问面试题.通俗的说: UITableView 有一个 Cell 对象的重用池,其中存放着当前页面显示的 Cell(在某些设备上,可能会再多几个.当 UITableView 滚动时,离开屏幕的 Cell 会被放到重用池中.有新的 Cell 要显示,则又从重用池中取.这样的好处显而易见,如果 UITableView 有一万行,我们不需要真的去创建一万个 Cell 对象.</p>
<h3 id="u7F13_u5B58_u9AD8_u5EA6"><a href="#u7F13_u5B58_u9AD8_u5EA6" class="headerlink" title="缓存高度"></a>缓存高度</h3><p>如果我们的 UITableViewCell 有复杂的动态高度,那么我们需要缓存每个 Cell 的高度.因为 UITableView 是继承 UIScrollView,需要先确定 contentSize.既然我们的 Cell 需要动态计算高度的,如果我们有一万个 Cell, 那么在创建 UITableView 时 <code>- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;</code> 会被调用一万次哦.如果你 reload 一下,又是一万次哦~.当 UITableView 滚动时,又会调用 <code>- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;</code> 既然这个方法会被调用那么多次,我们可以在网络到 UITableView 的数据源时,计算出一个 Cell 高度数组.</p>
<h3 id="u900F_u660E_u56FE_u5C42"><a href="#u900F_u660E_u56FE_u5C42" class="headerlink" title="透明图层"></a>透明图层</h3><p>透明图层对渲染性能会有一定的影响,因为混合(blending)是渲染中最慢的操作,系统会将透明图层与下面的视图混合起来计算并绘制图层属性,减少透明图层并使用不透明的图层来替代它们,在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成,可以大量提高 GPU 的计算速度.<br>可以通过 instrument 的 Core Animation 中开启 Color Blended Layers<br>,然后红色的部分就是我们需要重点消灭的区域.<br><img src="" alt=""></p>
<h3 id="u51CF_u5C11_u79BB_u5C4F_u6E32_u67D3"><a href="#u51CF_u5C11_u79BB_u5C4F_u6E32_u67D3" class="headerlink" title="减少离屏渲染"></a>减少离屏渲染</h3><p>CALayer 的 border、圆角、阴影、遮罩(mask),CAShapeLayer 的矢量图形显示,通常会触发离屏渲染(offscreen rendering).与之相对的是当前屏幕渲染(On-Screen Rendering),指的是渲染操作是用于在当前屏幕显示的缓冲区进行.离屏渲染需要多次切换上下文环境,先是从当前屏幕(On-Screen)切换到离屏(Off-Screen),等到离屏渲染结束以后,将离屏缓冲区的渲染结果显示到屏幕上又需要将上下文环境从离屏切换到当前屏幕,而上下文环境的切换是一项高开销的动作.<br>通常我们会一个 view 设置阴影会使用 <code>shadowoffset</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UIView *diamondView = [[UIView alloc] init];</span><br><span class="line">diamondView.layer.shadowOffset = CGSizeMake(<span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">diamondView.layer.shadowRadius = <span class="number">5.0f</span>;</span><br><span class="line">diamondView.layer.shadowOpacity = <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure>
<p>但是这种方式会触发离屏渲染造成不必要的开销,那么既要实现阴影图层,又要减少离屏渲染,提高性能的话.有什么更好的方式么?</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">UIView</span> *diamondView = [[UIView alloc] init]<span class="comment">;</span></span><br><span class="line"><span class="label">diamondView.layer.shadowPath</span> = [UIBezierPath <span class="keyword">bezierPathWithRect:CGRectMake(diamondView.bounds.origin.x </span>+ <span class="number">1</span>, diamondView.<span class="keyword">bounds.origin.y </span>+ <span class="number">1</span>, diamondView.<span class="keyword">bounds.size.width, </span>diamondView.<span class="keyword">bounds.size.height)].CGPath;</span><br><span class="line"></span><span class="label">imageView.layer.shadowOpacity</span> = <span class="number">0</span>.<span class="number">5</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>但是 <code>shadowPath</code> 只适用于给规则的矩形生成阴影路径.如果我们迫不得已要使用 <code>shadowoffset</code>,可以尝试开启 CALayer.shouldRasterize 属性, 图像将会被缓存起来并绘制到实际图层的 contents 和子图层.将原本在 GPU 中的一些工作让 CPU 来做,让两者达到一个平衡.但是这并不是有一个全优解,因为光栅化原始图像需要时间,而且会消耗额外的内存.所以一定要避免在内容不断变动的图层上使用,不然缓存的优势将荡然无存.</p>
<h3 id="u6309_u9700_u52A0_u8F7D_Cell"><a href="#u6309_u9700_u52A0_u8F7D_Cell" class="headerlink" title="按需加载 Cell"></a>按需加载 Cell</h3><p>当快速滑动 UITableView 的时候,计算出将要滚动到的 Cell 开始预加载,在滚动过程中的 Cell 选择不加载,这样可以极大的提高流畅度,同时也会出现一个问题就是,过程中会出现大量白色的 Cell.简单实现了下:<br>先监听 ScrollView 的滚动事件 </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scroll view delegate</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MainTableViewController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开始滑动</span></span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">scrollViewWillBeginDragging</span><span class="params">(scrollView: UIScrollView)</span></span> &#123;</span><br><span class="line">        targetRect = <span class="literal">nil</span></span><br><span class="line">        loadImageForVisibleCells()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将要结束拖拽</span></span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">scrollViewWillEndDragging</span><span class="params">(scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer&lt;CGPoint&gt;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: targetContentOffset.memory.x, y: targetContentOffset.memory.y, width: scrollView.bounds.width, height: scrollView.bounds.height)</span><br><span class="line">        targetRect = <span class="type">NSValue</span>(<span class="type">CGRect</span>: rect)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">scrollViewDidEndDecelerating</span><span class="params">(scrollView: UIScrollView)</span></span> &#123;</span><br><span class="line">        targetRect = <span class="literal">nil</span></span><br><span class="line">        loadImageForVisibleCells()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过判断是否为目标 Cell 选择性的加载 Subview</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MainTableViewController</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">setupCell</span><span class="params">(cell: MainTableViewCell, atIndexPath indexPath: NSIndexPath)</span></span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 判断一下是否是 目标 cell  如果不是的话 进行图片操作</span></span><br><span class="line">        <span class="keyword">var</span> imageURL: <span class="type">NSURL</span>? = cell.imgContent.sd_imageURL()</span><br><span class="line">        <span class="keyword">let</span> currentURL = tableViewDataArr[indexPath.row]</span><br><span class="line">        <span class="keyword">if</span> imageURL == <span class="literal">nil</span> &#123;</span><br><span class="line">            imageURL = <span class="type">NSURL</span>(string: <span class="string">""</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !(imageURL!.isEqual(currentURL)) &#123;</span><br><span class="line">            cell.imgContent.alpha = <span class="number">0.0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> manager = <span class="type">SDWebImageManager</span>.sharedManager()</span><br><span class="line">            <span class="keyword">let</span> cellFrame = tableView.rectForRowAtIndexPath(indexPath)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> shouldLoadImage = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 目标 cell 在屏幕中显示</span></span><br><span class="line">            <span class="keyword">if</span> targetRect != <span class="literal">nil</span> &amp;&amp; <span class="type">CGRectIntersectsRect</span>(targetRect.<span class="type">CGRectValue</span>(), cellFrame) &#123;</span><br><span class="line">                <span class="keyword">let</span> cache = manager.imageCache</span><br><span class="line">                <span class="keyword">let</span> key = manager.cacheKeyForURL(tableViewDataArr[indexPath.row])</span><br><span class="line">                <span class="keyword">if</span> cache.imageFromMemoryCacheForKey(key) == <span class="literal">nil</span> &#123;</span><br><span class="line">                    shouldLoadImage = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> shouldLoadImage &#123;</span><br><span class="line">                cell.imgContent.sd_setImageWithURL(tableViewDataArr[indexPath.row], placeholderImage: <span class="literal">nil</span>, completed: &#123; (image, <span class="type">ErrorType</span>, cacheType, imageURL) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">if</span> imageURL.isEqual(<span class="keyword">self</span>.tableViewDataArr[indexPath.row]) &#123;</span><br><span class="line">                        <span class="type">UIView</span>.animateWithDuration(<span class="number">0.25</span>, animations: &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                            cell.imgContent.alpha = <span class="number">1.0</span></span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">loadImageForVisibleCells</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> visiblesCells = tableView.visibleCells <span class="keyword">as</span>! [<span class="type">MainTableViewCell</span>]</span><br><span class="line">        <span class="keyword">for</span> cell <span class="keyword">in</span> visiblesCells &#123;</span><br><span class="line">            <span class="keyword">let</span> indexPath = tableView.indexPathForCell(cell)</span><br><span class="line">            setupCell(cell, atIndexPath: indexPath!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h3><ol>
<li>减少 Cell 中的 Subview 的数量</li>
<li>尽可能使用静态 cell</li>
<li>使用<code>rowHeight</code>, <code>sectionFooterHeight</code> 和 <code>sectionHeaderHeight</code>来设定固定的高度</li>
<li>减少 Cell 的种类,过多的 CellIndentifier 使 Cell 的重用池中存在大量的 Cell 实例对象.</li>
</ol>
]]></content:encoded>
      <comments>http://broccolii.github.io/2016/01/26/UITableView_Optimization/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[ReactiveCocoa 整理]]></title>
      <link>http://broccolii.github.io/2015/12/31/ReactiveCocoa_exploration/</link>
      <guid>http://broccolii.github.io/2015/12/31/ReactiveCocoa_exploration/</guid>
      <pubDate>Wed, 30 Dec 2015 19:52:39 GMT</pubDate>
      <description>
      <![CDATA[<h3 id="ReactiveCocoa__u662F_u4EC0_u4E48"><a href="#ReactiveCocoa__u662F_u4EC0_u4E48" class="headerlink" title="ReactiveCocoa 是什么"></a>React]]>
      </description>
      <content:encoded><![CDATA[<h3 id="ReactiveCocoa__u662F_u4EC0_u4E48"><a href="#ReactiveCocoa__u662F_u4EC0_u4E48" class="headerlink" title="ReactiveCocoa 是什么"></a>ReactiveCocoa 是什么</h3><p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a>（简称为RAC）,是由 Github 开源的一个应用于iOS和OS开发的新框架.是一个 iOS 中的函数式响应式编程框架.(注: 文本例子使用 ReactiveCocoa 2.5)</p>
<h3 id="ReactiveCocoa__u7684_u4F5C_u7528"><a href="#ReactiveCocoa__u7684_u4F5C_u7528" class="headerlink" title="ReactiveCocoa 的作用"></a>ReactiveCocoa 的作用</h3><p>在 iOS 开发过程中,我们需要监听不同的事件,并作出反应,例如对 <code>UIButton</code> 的点击事件使用 <code>TA</code> 模式,对 <code>UIScrollView</code> 的滚动事件使用 <code>delegate</code>,对属性变化监听使用 <code>KVO</code>.那么我们可能会想能不能使用同一的标准? <code>ReactiveCocoa</code> 为我们提供了一个单独的、统一的方法来这些行为.它可以把要处理的事情,和监听的事情的代码放在一起,便于我们管理代码,非常符合我们开发中<code>高聚合,低耦合</code>的思想.</p>
<h3 id="u7F16_u7A0B_u8303_u5F0F_3A__u51FD_u6570_u5F0F_u7F16_u7A0B_/__u54CD_u5E94_u5F0F_u7F16_u7A0B"><a href="#u7F16_u7A0B_u8303_u5F0F_3A__u51FD_u6570_u5F0F_u7F16_u7A0B_/__u54CD_u5E94_u5F0F_u7F16_u7A0B" class="headerlink" title="编程范式: 函数式编程 / 响应式编程"></a>编程范式: 函数式编程 / 响应式编程</h3><p><em>ReactiveCocoa被描述为函数响应式编程（FRP）框架,使用 FRP 有两个好处: 直观和灵活.</em><br><strong>函数式编程(Functional Programming)</strong><br>函数式编程(functional programming)简单的来说就是一种编程范型,主要思想是把运算过程尽量写成一系列嵌套的函数调用.函数编程语言最重要的基础是 λ 演算(lambda calculus),而且 λ 演算的函数可以接受函数当作输入和输出.函数式编程更加强调程序执行的结果而非执行的过程,倡导利用若干简单的执行单元让计算结果不断渐进,逐层推导复杂的运算,而不是设计一个复杂的执行过程.<br>阮一峰老师有一个关于<a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank" rel="external">函数式编程</a>的例子,如下:</p>
<blockquote>
<p>举例来说,现在有这样一个数学表达式：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span> + <span class="number">2</span>) * <span class="number">3</span> - <span class="number">4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可能会这样写:</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> a</span> = <span class="number">1</span> + <span class="number">2</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> b</span> = a * <span class="number">3</span>　　</span><br><span class="line"><span class="variable"><span class="keyword">var</span> c</span> = b - <span class="number">4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数式编程要求使用函数,我们可以把运算过程定义为不同的函数,然后写成下面这样：</p>
</blockquote>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">result</span> = subtract(multiply(add(<span class="number">1</span>,<span class="number">2</span>), <span class="number">3</span>), <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这就是函数式编程</p>
</blockquote>
<p><strong>响应式编程(Reactive Programming).</strong><br>响应式编程是一种面向数据流和变化传播的编程范式.这意味着可以在编程语言中很方便地表达静态或动态的数据流,而相关的计算模型会自动将变化的值通过数据流进行传播.我们看一下刚刚阮老师的代码 <code>var b = a * 3</code> 如果 <code>a</code> 的值从 3 变成了 5, 那么 <code>b</code> 的值会随着 <code>a</code> 的变化而变化. <code>b</code> 的值就从 9 变为了 15.</p>
<h3 id="ReactiveCocoa__u57FA_u672C_u6982_u5FF5"><a href="#ReactiveCocoa__u57FA_u672C_u6982_u5FF5" class="headerlink" title="ReactiveCocoa 基本概念"></a>ReactiveCocoa 基本概念</h3><p><strong>RACSignal</strong><br>ReactiveCocoa 的核心就是 RACSignal,也就是信号,我们可以直接创建信号 <code>createSignal</code>,并发送 <code>sendNext</code> 进行下一步操作,当信号完成后我们可以调用 <code>sendCompleted</code>,我们同时用 <code>dispose</code> 方法销毁它 .当然如果信号因为发生错误而终止,也可以发送错误信号 <code>sendError</code>.当我们使用了 <code>sendCompleted</code> 和 <code>sendError</code> 就不能继续发送 <code>sendNext</code>,因为信号已经终止结束.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建信号</span></span><br><span class="line">RACSignal *signal = [RACSignal <span class="string">createSignal:</span>^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">	<span class="comment">// 发送信号</span></span><br><span class="line">   [subscriber <span class="string">sendNext:</span>@<span class="string">"下一步"</span>];</span><br><span class="line">   [subscriber <span class="string">sendError:</span>[NSError <span class="keyword">new</span>]];</span><br><span class="line">   [subscriber sendCompleted];</span><br><span class="line">   <span class="comment">// 取消订阅</span></span><br><span class="line">   <span class="keyword">return</span> [RACDisposable <span class="string">disposableWithBlock:</span>^&#123;</span><br><span class="line">      <span class="comment">// 信号被销毁时调用</span></span><br><span class="line">   &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>如下图所示: 我们可以使用 RACSignal 可以来替代 iOS 中传统的 Delegate,Block,Target Action,KVO,Notification.</p>
<div style="text-align: center"><br><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/ReactiveCocoa_exploration/RACSignal.jpg"><br></div>

<p>创建了一个信号,需要有订阅者来接受它,否则它就是一个待激活的状态.可以使用 <code>subscribeNext:</code> 激活信号.此时有了订阅者,才会发生 <code>sendNext:</code>, <code>sendError:</code>, <code>sendCompleted</code>. 所以一个信号的正确流程应该是 1. 创建信号,2. 订阅信号, 3. 发送信号.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅信号</span></span><br><span class="line">[signal <span class="string">subscribeNext:</span>^(id x) &#123;</span><br><span class="line">   <span class="comment">// 接收 next 操作</span></span><br><span class="line">&#125; <span class="string">error:</span>^(NSError *error) &#123;</span><br><span class="line">   <span class="comment">// 接收 error 操作</span></span><br><span class="line">&#125; <span class="string">completed:</span>^&#123;</span><br><span class="line">   <span class="comment">// 接收 complete 操作</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><strong>RACSubscriber</strong><br>我们现在对信号的产生和发送有了一些了解, 在 ReactiveCocoa 中,其实并不存在一个订阅者的实例,凡是实现 <code>RACSubscriber</code> 协议的类都可以作为订阅者.<br>协议里有四个方法</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@protocol</span> RACSubscriber &lt;NSObject&gt;</span><br><span class="line"><span class="annotation">@required</span></span><br><span class="line"></span><br><span class="line">- (<span class="typename">void</span>)<span class="string">sendNext:</span>(id)value;</span><br><span class="line">- (<span class="typename">void</span>)<span class="string">sendError:</span>(NSError *)error;</span><br><span class="line">- (<span class="typename">void</span>)sendCompleted;</span><br><span class="line">- (<span class="typename">void</span>)<span class="string">didSubscribeWithDisposable:</span>(RACCompoundDisposable *)disposable;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>-sendNext:</code>,<code>-sendError:</code> 和 <code>-sendCompleted</code>,刚刚我们用于发送了不同类型的信号, 而 <code>didSubscribeWithDisposable:</code> 用于接收代表某次订阅的 disposable 对象,告诉订阅者你订阅了哪些信号.我们也可以用返回的 <code>RACDisposable</code> 手动取消订阅者</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RACDisposable *disposable = [signal <span class="string">subscribeNext:</span>^(id x) &#123;</span><br><span class="line">   <span class="comment">// 接收 next 操作</span></span><br><span class="line">&#125; <span class="string">error:</span>^(NSError *error) &#123;</span><br><span class="line">   <span class="comment">// 接收 error 操作</span></span><br><span class="line">&#125; <span class="string">completed:</span>^&#123;</span><br><span class="line">   <span class="comment">// 接收 complete 操作</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 手动取消订阅者    </span></span><br><span class="line">[disposable dispose];</span><br></pre></td></tr></table></figure>
<p>RACSignal 默认替我们实现了 <code>RACSubscriber</code> 协议,点进 RACSignal 的源码可以在 <code>@implementation RACSignal (Subscription)</code> 看到,实现订阅者的方法.这里有一个与 <code>RACSubscriber</code> 协议同名的 <code>RACSubscriber</code>类.这与 <code>NSObject</code> 协议与 <code>NSObject</code>类同名类似. <code>RACSubscriber</code> 类就是真正的订阅者,不过在 ReactiveCocoa 中,倾向于隐藏订阅者,让程序员只关注信号就可以了.</p>
<p><strong>RACDisposable</strong><br>RACDisposable 用于取消订阅与资源清理(cancellation and resource cleanup).当信号发送完成或发送错误的时候,就会自动触发 <code>[disposable dispose];</code>.</p>
<p><strong>RACSubject</strong><br>RACSubject 是一个可以手动控制的信号,我们可以把它看作是 RACSignal 的可变版本.RACSubject 继承自 RACSignal ,所以它可以作为信号源被订阅者订阅,同时,它又实现了 RACSubscriber 协议,所以它也可以作为订阅者订阅其他信号源. RACSubject 可以看作是信号的一个可变体(variant),就像NSMutableArray之于NSArray.它对于桥接(bridging)非RAC代码到信号中去(into the world of signals)非常有用.RACSubject 的功能非常强大,但是太过灵活,也正是因为如此,我们只有在迫不得已的情况下才会使用它.</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">RACSubject</span> *<span class="atom">signal</span> = [<span class="name">RACSubject</span> <span class="atom">subject</span>];</span><br><span class="line">[<span class="atom">signal</span> <span class="atom">subscribeNext</span>:^(<span class="atom">id</span> <span class="atom">x</span>) &#123;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[<span class="atom">signal</span> <span class="atom">sendNext</span>:@<span class="string">"signal"</span>];</span><br></pre></td></tr></table></figure>
<p><strong>RACSequence</strong><br>RACSequence 类可以简单看做是 ReactiveCocoa 的 NSArray, ReactiveCocoa使用 <code>rac_sequence</code> 方法,可以使 Objective-C 中的集合类（collection classes）直接转换为RACSequence 来使用</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">NSArray</span> *numbers = <span class="annotation">@[<span class="variable">@1</span>,<span class="variable">@2</span>,<span class="variable">@3</span>,<span class="variable">@4</span>]</span>;</span><br><span class="line">[numbers.rac_sequence.signal <span class="symbol">subscribeNext:</span>^(id x) &#123;</span><br><span class="line"><span class="regexp">//</span> 遍历数组</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><strong>RACScheduler</strong><br>RACScheduler 在 ReactiveCocoa 中类似 GCD 的队列,是管理线程的一个类.负责 ReactiveCocoa 中让信号发出的事件在线程中穿梭,尤其是想更新 UI 必须在主线程中的时候,可以让事件直接从其他线程跳到主线程.本质上它是基于 GCD 的串行队列实现,并且支持取消操作.</p>
<p><strong>RACMulticastConnection</strong><br>RACMulticastConnection 是一个在任意数量订阅者之间共享的一个订阅者(subscription).<br>信号在默认情况下是冷的,每当添加一个新的订阅,信号的 block 就会被调用一次,如果 block 中实现的是网络请求,那么会发生多次请求.(这里与 replay 不同的是,replay 是会产生多次信号,不过只发送第一次的,而 RACMulticastConnection 只会产生一次)</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"网络请求"</span>);</span><br><span class="line">   [subscriber sendNext:<span class="string">@"signal"</span>];</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACMulticastConnection *connect = [signal publish];</span><br><span class="line"></span><br><span class="line">[connect<span class="variable">.signal</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[connect<span class="variable">.signal</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.连接,激活信号</span></span><br><span class="line">[connect connect];</span><br></pre></td></tr></table></figure>
<h3 id="ReactiveCocoa__u4E2D_u7684_u5E38_u7528_u5F02_u6B65_u5904_u7406"><a href="#ReactiveCocoa__u4E2D_u7684_u5E38_u7528_u5F02_u6B65_u5904_u7406" class="headerlink" title="ReactiveCocoa 中的常用异步处理"></a>ReactiveCocoa 中的常用异步处理</h3><ul>
<li>Delegate (有局限,只能取代没有返回值的代理方法)</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="keyword">self</span> rac_signalForSelector:<span class="keyword">@selector</span>(textFieldDidBeginEditing:)</span><br><span class="line"> fromProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">UITextFieldDelegate</span>)]</span></span><br><span class="line"> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="comment">// 代理方法</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<ul>
<li>Target-Action</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[button rac_signalForControlEvents:UIControlEventTouchUpInside]</span></span><br><span class="line"> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">// 点击事件  </span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>KVO</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[RACObserve<span class="list">(<span class="keyword">scrollView</span>, contentOffset)</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">// 监听 scrollView 的偏移量</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Notification</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[NSNotificationCenter defaultCenter]</span> rac_addObserverForName:UIApplicationDidEnterBackgroundNotification object:nil]</span> subscribeNext:^<span class="list">(<span class="keyword">NSNotification</span> * notification)</span> <span class="collection">&#123;</span><br><span class="line">// 收到通知 </span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定时器</li>
</ul>
<p>1.延迟一段时间后再做某件事</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[[RACScheduler mainThreadScheduler]</span> <span class="tag">afterDelay</span><span class="pseudo">:2</span> <span class="tag">schedule</span>:^&#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>2.每个一定长度时间做一件事</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[RACSignal interval:1 onScheduler:<span class="collection">[RACScheduler mainThreadScheduler]</span>]</span>subscribeNext:^<span class="list">(<span class="keyword">NSDate</span> * date)</span> <span class="collection">&#123;</span><br><span class="line">// do something</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>手势</li>
</ul>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UITapGestureRecognizer *tap = <span class="comment">[<span class="comment">[UITapGestureRecognizer alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[<span class="comment">[tap rac_gestureSignal]</span> subscribeNext:^(UITapGestureRecognizer * tap) &#123;</span><br><span class="line">// 手势操作</span><br><span class="line">&#125;]</span>;</span><br><span class="line"><span class="comment">[self.view addGestureRecognizer:tap]</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>文本框文字改变 </li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[textField rac_textSignal]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="u5B8F_u5B9A_u4E49"><a href="#u5B8F_u5B9A_u4E49" class="headerlink" title="宏定义"></a>宏定义</h3><p><strong>RAC()</strong> 可以将 RACSignal 发出事件的值赋给某个对象的某个属性</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(self.labelView,<span class="keyword">text</span>) = <span class="keyword">textField</span>.rac_textSignal;</span><br></pre></td></tr></table></figure>
<p><strong>RACObserve()</strong> 新建一个 <code>RACSignal</code> 并对对象的属性的值进行观察</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[RACObserve<span class="list">(<span class="keyword">textField</span>, text)</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">// 当 text 发生改变时,会接收到信号</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>RACTuplePack</strong> 把数据包装成 RACTuple 类型</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACTuple *tuple = RACTuplePack(<span class="constant">@10</span>,<span class="constant">@20</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>RACTupleUnpack</strong> 把 RACTuple 类型解包</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// num1 = 10, num2 = 20</span></span><br><span class="line">RACTupleUnpack(<span class="built_in">NSNumber</span> *num1,<span class="built_in">NSNumber</span> *num2) = tuple;</span><br></pre></td></tr></table></figure>
<p><strong>@weakify(Obj) / @strongify(Obj)</strong><br>用来生成 <code>__weak的self_weak_变量</code> 和 <code>__strong的self指针指向self_weak</code> 用来处理 block 调用中的 循环引用.实现细节可以参考 <a href="http://blog.sunnyxx.com/2014/03/06/rac_1_macros/" target="_blank" rel="external">sunnyxx 大神的 神奇的Macros</a></p>
<h3 id="u5E38_u7528_u64CD_u4F5C"><a href="#u5E38_u7528_u64CD_u4F5C" class="headerlink" title="常用操作"></a>常用操作</h3><p>例子摘自<a href="http://www.jianshu.com/p/e10e5ca413b7" target="_blank" rel="external">最快让你上手ReactiveCocoa之进阶篇</a> 和 <a href="http://ios.jobbole.com/82356/" target="_blank" rel="external">这样好用的ReactiveCocoa,根本停不下来</a>(PS: 如果知道原文地址请告知 :) )</p>
<h5 id="u6620_u5C04"><a href="#u6620_u5C04" class="headerlink" title="映射"></a>映射</h5><ul>
<li>map 将信号的值映射成一个新值</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UITextField</span> *textField= [[<span class="built_in">UITextField</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">30</span>)];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:textField];</span><br><span class="line">    </span><br><span class="line">[[[textField rac_textSignal] map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">@"map 过的值"</span>;</span><br><span class="line">&#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">  <span class="comment">// 处理 map 之后的值</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<ul>
<li>flattenMap 将信号映射成新的信号</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">   NSLog<span class="list">(@<span class="string">"第一步操作"</span>)</span><span class="comment">;</span></span><br><span class="line">   <span class="collection">[subscriber sendNext:@<span class="string">"第二步操作"</span>]</span><span class="comment">;</span></span><br><span class="line">   <span class="collection">[subscriber sendCompleted]</span><span class="comment">;</span></span><br><span class="line">   return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> flattenMap:<span class="comment">^RACStream</span> *<span class="list">(<span class="keyword">NSString*</span> value)</span> <span class="collection">&#123;</span><br><span class="line">   return <span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">       NSLog<span class="list">(@<span class="string">"现在进行的是: %@"</span>,value)</span><span class="comment">;</span></span><br><span class="line">       <span class="collection">[subscriber sendNext:@<span class="string">"操作完毕"</span>]</span><span class="comment">;</span></span><br><span class="line">       <span class="collection">[subscriber sendCompleted]</span><span class="comment">;</span></span><br><span class="line">       return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">   &#125;</span>]</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">   // x = 操作完毕</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="u7EC4_u5408"><a href="#u7EC4_u5408" class="headerlink" title="组合"></a>组合</h4><ul>
<li>concat 按顺序拼接信号,并且有顺序地接收信号</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal <span class="string">createSignal:</span>^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber <span class="string">sendNext:</span>@<span class="string">"我先做完才能做 B"</span>];</span><br><span class="line">   [subscriber sendCompleted];</span><br><span class="line">   <span class="keyword">return</span> nil;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">RACSignal *signalB = [RACSignal <span class="string">createSignal:</span>^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber <span class="string">sendNext:</span>@<span class="string">"我要等 A 做完了才能开始"</span>];</span><br><span class="line">   [subscriber sendCompleted];</span><br><span class="line">   <span class="keyword">return</span> nil;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">[[signalA <span class="string">concat:</span>signalB] <span class="string">subscribeNext:</span>^(id x) &#123;</span><br><span class="line">   <span class="comment">// 输出</span></span><br><span class="line">   <span class="comment">// 我先做完才能做 B</span></span><br><span class="line">   <span class="comment">// 我要等 A 做完了才能开始</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<ul>
<li>then 用于连接多个信号当前一个信号结束,开始下一个信号.</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[<span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">   NSLog<span class="list">(@<span class="string">"第一步"</span>)</span><span class="comment">;</span></span><br><span class="line">   <span class="collection">[subscriber sendCompleted]</span><span class="comment">;</span></span><br><span class="line">   return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> then:<span class="comment">^RACSignal</span> *<span class="collection">&#123;</span><br><span class="line">   return <span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">       NSLog<span class="list">(@<span class="string">"第二步"</span>)</span><span class="comment">;</span></span><br><span class="line">       <span class="collection">[subscriber sendCompleted]</span><span class="comment">;</span></span><br><span class="line">       return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">   &#125;</span>]</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> then:<span class="comment">^RACSignal</span> *<span class="collection">&#123;</span><br><span class="line">   return <span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">       NSLog<span class="list">(@<span class="string">"第三步"</span>)</span><span class="comment">;</span></span><br><span class="line">       <span class="collection">[subscriber sendCompleted]</span><span class="comment">;</span></span><br><span class="line">       return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">   &#125;</span>]</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> subscribeCompleted:<span class="comment">^&#123;</span><br><span class="line">   NSLog(@"第四步");</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>merge 将多个信号合并为一个,任何一个信号发出就会调用</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber sendNext:@<span class="string">"信号一"</span>];</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber sendNext:@<span class="string">"信号二"</span>];</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="string">[[RACSignal merge:@[signalA, signalB]]</span> subscribeNext:^(id x) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<ul>
<li>zipWith 将多个信号合并为一个多个信号发出就会调用,接受的值为一个元组</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal <span class="string">createSignal:</span>^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber <span class="string">sendNext:</span>@<span class="string">"signalA"</span>];</span><br><span class="line">   <span class="keyword">return</span> nil;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">RACSignal *signalB = [RACSignal <span class="string">createSignal:</span>^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber <span class="string">sendNext:</span>@<span class="string">"signalB"</span>];</span><br><span class="line">   <span class="keyword">return</span> nil;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">[[signalA <span class="string">zipWith:</span>signalB] <span class="string">subscribeNext:</span>^(id x) &#123;</span><br><span class="line">   </span><br><span class="line">   NSLog(@<span class="string">"%@"</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<ul>
<li>reduce 把信号发出元组的值聚合成一个值</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal <span class="string">createSignal:</span>^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber <span class="string">sendNext:</span>@<span class="string">"signalA"</span>];</span><br><span class="line">   <span class="keyword">return</span> nil;</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *signalB = [RACSignal <span class="string">createSignal:</span>^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber <span class="string">sendNext:</span>@<span class="string">"signalB"</span>];</span><br><span class="line">   <span class="keyword">return</span> nil;</span><br><span class="line">&#125;];</span><br><span class="line">[[RACSignal <span class="string">combineLatest:</span>@[sugarSignal, waterSignal] <span class="string">reduce:</span>^id (NSString *str1, NSString *str2)&#123;</span><br><span class="line">   <span class="keyword">return</span> [str1 <span class="string">stringByAppendingString:</span>str2];</span><br><span class="line">&#125;] <span class="string">subscribeNext:</span>^(id x) &#123;</span><br><span class="line">	<span class="comment">// 输出 "str1str2"</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="u8FC7_u6EE4"><a href="#u8FC7_u6EE4" class="headerlink" title="过滤"></a>过滤</h4><ul>
<li>filter 过滤信号</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[textField rac_textSignal]</span> filter:<span class="comment">^BOOL</span><span class="list">(<span class="keyword">id</span> value)</span> <span class="collection">&#123;</span><br><span class="line">   return textField.text.length &gt; <span class="number">6</span> ? YES : NO;</span><br><span class="line">&#125;</span>]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">  // 之后当 textField.text 的长度大于六位才会接收到信号</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ignore 忽略完某些值的信</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[textField rac_textSignal]</span> ignore:@<span class="string">"我是被忽略的值"</span>]</span> </span><br><span class="line">subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>distinctUntilChanged 只有当与上一个信号值不同时,才会发出信号</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[textField rac_textSignal]</span> distinctUntilChanged]</span> </span><br><span class="line">subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>take 取 N 次的信号</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *signal = [RACSubject subject];</span><br><span class="line">[[signal <span class="string">take:</span><span class="number">1</span>] <span class="string">subscribeNext:</span>^(id x) &#123;</span><br><span class="line">	<span class="comment">// 只会接受一次信号</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signal <span class="string">sendNext:</span>@<span class="number">1</span>];</span><br><span class="line">[signal <span class="string">sendNext:</span>@<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>takeLast 取最后 N 次的信号,订阅者必须调用完成.</li>
</ul>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *signal = <span class="comment">[RACSubject subject]</span>;</span><br><span class="line"><span class="comment">[<span class="comment">[signal takeLast:1]</span> subscribeNext:^(id x) &#123;</span><br><span class="line">	// 只会接受最后一次信号</span><br><span class="line">&#125;]</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">[signal sendNext:@1]</span>;</span><br><span class="line"><span class="comment">[signal sendNext:@2]</span>;</span><br><span class="line"><span class="comment">[signal sendCompleted]</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>takeUntil 监听信号直到某个信号执行完成</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[[textField rac_textSignal]</span> <span class="tag">takeUntil</span><span class="pseudo">:self</span><span class="class">.rac_willDeallocSignal</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>引用<a href="http://limboy.me/ios/2014/06/06/deep-into-reactivecocoa2.html" target="_blank" rel="external">limboy 大神的一个例子</a><br>它的常用场景之一是处理cell的button的点击事件,比如点击Cell的详情按钮,需要push一个VC,就可以这样:</p>
</blockquote>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[cell.detailButton</span><br><span class="line">    rac_signalForControlEvents:UIControlEventTouchUpInside]</span></span><br><span class="line">    takeUntil:cell.rac_prepareForReuseSignal]</span></span><br><span class="line">    subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">        // generate and push ViewController</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>skip 跳过 N 个信号</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[textField rac_textSignal]</span> skip:1]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>takeUntilBlock:(BOOL (^)(id x)) 对于每个信号的值,运行block,当block返回YES时停止.</li>
<li>takeWhileBlock:(BOOL (^)(id x)) 对于每个信号的值,运行block,当block返回NO时停止.</li>
<li>skipUntilBlock:(BOOL (^)(id x)) 对于每个信号的值,运行block,当block返回YES时停止跳过.</li>
<li>skipWhileBlock:(BOOL (^)(id x)) 对于每个信号的值,运行block,当block返回NO时停止跳过.</li>
</ul>
<h4 id="u79E9_u5E8F"><a href="#u79E9_u5E8F" class="headerlink" title="秩序"></a>秩序</h4><ul>
<li>doNext 执行 Next 之前,会先执行这个Block</li>
<li>doCompleted 执行 sendCompleted 之前,会先执行这个Block</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[<span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">  <span class="collection">[subscriber sendNext:@<span class="number">1</span>]</span><span class="comment">;</span></span><br><span class="line">  <span class="collection">[subscriber sendCompleted]</span><span class="comment">;</span></span><br><span class="line">  return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> doNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">// 执行<span class="collection">[subscriber sendNext:@<span class="number">1</span>]</span><span class="comment">;之前会调用这个Block</span></span><br><span class="line">  NSLog<span class="list">(@<span class="string">"doNext"</span>)</span><span class="comment">;;</span></span><br><span class="line">&#125;</span>]</span> doCompleted:<span class="comment">^&#123;</span><br><span class="line">   // 执行[subscriber sendCompleted];之前会调用这个Block</span><br><span class="line">  NSLog(@"doCompleted");;</span><br><span class="line"></span><br><span class="line">&#125;</span>]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line"></span><br><span class="line">  NSLog<span class="list">(@<span class="string">"%@"</span>,x)</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="u65F6_u95F4"><a href="#u65F6_u95F4" class="headerlink" title="时间"></a>时间</h4><ul>
<li>timeout 超时</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">   return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> timeout:10 onScheduler:<span class="collection">[RACScheduler currentScheduler]</span>]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span> error:^<span class="list">(<span class="keyword">NSError</span> *error)</span> <span class="collection">&#123;</span><br><span class="line">   // 十秒后调用</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>interval 定时</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[RACSignal interval:1 onScheduler:<span class="collection">[RACScheduler currentScheduler]</span>]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>delay 延迟调用 sendNext</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">   <span class="collection">[subscriber sendNext:@<span class="string">"signal"</span>]</span><span class="comment">;</span></span><br><span class="line">   return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> delay: <span class="number">10</span>]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">   // <span class="number">10</span> 秒后接收</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="u91CD_u590D"><a href="#u91CD_u590D" class="headerlink" title="重复"></a>重复</h4><ul>
<li>retry 重试,只要失败,就会重新执行创建信号中的block,直到成功.</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">[[[RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       <span class="keyword">if</span> (i == <span class="number">10</span>) &#123;</span><br><span class="line">           [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@"接收到错误"</span>);</span><br><span class="line">           [subscriber sendError:<span class="literal">nil</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       i++;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] retry] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"></span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<ul>
<li>replay 重放,当一个信号被多次订阅,只发送第一次的数据</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>; </span><br><span class="line">	[subscriber sendNext:@(a)];</span><br><span class="line">	a ++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] replay];</span><br><span class="line">    </span><br><span class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"第一个订阅者%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"第二个订阅者%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个输出都为 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>throttle 节流,当某个信号发送比较频繁时可以隔一段时间获取信号的最新内容</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在十秒内不接受任何信号内容,十秒后获取最后发送的信号内容</span></span><br><span class="line"><span class="attr_selector">[[[RACSubject subject]</span> <span class="tag">throttle</span><span class="pseudo">:10</span>] <span class="tag">subscribeNext</span>:^(id x) &#123;</span><br><span class="line">   </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="u8865_u5145"><a href="#u8865_u5145" class="headerlink" title="补充"></a>补充</h4><p>听了<a href="https://github.com/DeveloperLx" target="_blank" rel="external">DeveloperLx</a>关于 ReactiveCocoa 的分享,记录一下一个优化即时搜索的代码段,很值得学习.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UITextField</span> * textField = [[<span class="built_in">UITextField</span> alloc]init];</span><br><span class="line">textField<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> cyanColor];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:textField];</span><br><span class="line">   </span><br><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line">[textField mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">  @strongify(<span class="keyword">self</span>);</span><br><span class="line">  make<span class="variable">.size</span><span class="variable">.mas_equalTo</span>(<span class="built_in">CGSizeMake</span>(<span class="number">180</span>, <span class="number">40</span>));</span><br><span class="line">  make<span class="variable">.center</span><span class="variable">.equalTo</span>(<span class="keyword">self</span><span class="variable">.view</span>);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//throttle 后面是个时间 表示rac_textSignal发送消息，0.3秒内没有再次发送就会相应，若是0.3内又发送消息了，便会在新的信息处重新计时</span></span><br><span class="line"><span class="comment">//distinctUntilChanged 表示两个消息相同的时候，只会发送一个请求</span></span><br><span class="line"><span class="comment">//ignore 表示如果消息和ignore后面的消息相同，则会忽略掉这条消息，不让其发送</span></span><br><span class="line">[[[[[[textField<span class="variable">.rac_textSignal</span> throttle:<span class="number">0.3</span>] distinctUntilChanged] ignore:<span class="string">@""</span>] map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//  network request</span></span><br><span class="line">      [subscriber sendNext:value];</span><br><span class="line">      [subscriber sendCompleted];</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//  cancel request</span></span><br><span class="line">      &#125;];</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;]switchToLatest] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">  </span><br><span class="line">  LxDBAnyVar(x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>这样做给服务器减小了很多的压力，更是节省了我们大量的代码。 其中我们用map建立了一个新的信号，我们知道textField的改变是一个信号， map就是在这个信号上，又加了一个信号，即signal of signals。<br>订阅者所打印的消息x则是，map发出的信号。我们可以再map中发送新的信号，以及取消信号disposable.<br>当我们用map发送信号的时候，我们则需要使用 switchToLatest这个参数来获取最后一个信号，也就是我们最后所打印的x，就是map最后发错的这个信号。</p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>未完待续</p>
]]></content:encoded>
      <comments>http://broccolii.github.io/2015/12/31/ReactiveCocoa_exploration/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[iOS9 中的 3D Touch]]></title>
      <link>http://broccolii.github.io/2015/11/06/iOS9_3D_Touch/</link>
      <guid>http://broccolii.github.io/2015/11/06/iOS9_3D_Touch/</guid>
      <pubDate>Fri, 06 Nov 2015 00:52:23 GMT</pubDate>
      <description>
      <![CDATA[<p>Apple 发布了 iPhone 6s / 6s Plus,为了 3D Touch 这个功能新款 iPhone 变得更重更厚.果然是 <code>唯一的不同,是处处都不同</code>(笑.让我们来动手试一下.</p>
<h4 id="Peek_/_Pop"><a href]]>
      </description>
      <content:encoded><![CDATA[<p>Apple 发布了 iPhone 6s / 6s Plus,为了 3D Touch 这个功能新款 iPhone 变得更重更厚.果然是 <code>唯一的不同,是处处都不同</code>(笑.让我们来动手试一下.</p>
<h4 id="Peek_/_Pop"><a href="#Peek_/_Pop" class="headerlink" title="Peek / Pop"></a>Peek / Pop</h4><p>Peek: 轻压,操作能让用户在不离开当前界面的情况下预览内容.<br>Pop: 则是当用户在 peek 弹出的视图上加重按压力度,显示更详细的内容.</p>
<p>我们先写一个 UITableViewController 的主页面</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: - UITableViewDateSource</span></span><br><span class="line"><span class="keyword">let</span> <span class="type">CellIdentifier</span> = <span class="string">"TableViewCell"</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MainViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(<span class="type">CellIdentifier</span>, forIndexPath: indexPath)</span><br><span class="line">        cell.textLabel!.text = <span class="string">"第 <span class="subst">\(indexPath.row)</span> 行 Cell"</span></span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在要实现一下,点击 Cell 然后弹出一个预览视图<br><img src="https://github.com/broccolii/broccolii.github.io/raw/master/images/iOS9_3D_Touch/Peek.png" alt=""></p>
<p>.先让 MainViewControler 实现 <code>UIViewControllerPreviewingDelegate</code> 协议</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: - UIViewControllerPreviewingDelegate</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MainViewController</span>: <span class="title">UIViewControllerPreviewingDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 轻按 预览界面</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">previewingContext</span><span class="params">(previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint)</span></span> -&gt; <span class="type">UIViewController</span>? &#123;</span><br><span class="line">        <span class="keyword">guard</span> #available(iOS <span class="number">9.0</span>, *) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">debugPrint</span>(<span class="string">"只支持 iOS 9.0 以上版本"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> indexPath = tableView.indexPathForRowAtPoint(location) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> originRect = tableView.cellForRowAtIndexPath(indexPath)!.frame</span><br><span class="line">        previewingContext.sourceRect = view.convertRect(originRect, fromView: tableView)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 这里不能直接获取到 控件 还未创建</span></span><br><span class="line">        <span class="keyword">let</span> previewVC = storyboard!.instantiateViewControllerWithIdentifier(<span class="string">"PreviewViewController"</span>) <span class="keyword">as</span>! <span class="type">PreviewViewController</span></span><br><span class="line">        previewVC.previewText = <span class="string">"你点击了 <span class="subst">\(indexPath.row)</span> 行 Cell"</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> previewVC</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重按 进入页面</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">previewingContext</span><span class="params">(previewingContext: UIViewControllerPreviewing, commitViewController viewControllerToCommit: UIViewController)</span></span> &#123;</span><br><span class="line"><span class="comment">//        可以选择跳转正常业务流程的界面</span></span><br><span class="line"><span class="comment">//        performSegueWithIdentifier("gotoDetailViewController", sender: nil)</span></span><br><span class="line">        <span class="comment">// 也可以选择直接使用 preview view controller </span></span><br><span class="line">        showViewController(viewControllerToCommit, sender: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>方法一(Peek): 用来显示预览视图,通过 <code>location</code> 判断点击了哪一个 cell.在 iOS9 中提供了 <code>sourceRect</code> 属性,可以获取目标 Rect,获得更好的弹出效果.这里需要注意的地方是 <code>previewVC</code> 的控件还未创建是 nil. 如果我们需要对控件赋值,需要通过一个属性,在 <code>viewDidLoad</code> 中赋值.</li>
<li>方法二(Pop): 重击进入下一个页面,显示详细信息.这里可以选择跳转原本的业务逻辑,也可以直接进入 previewVC.</li>
</ol>
<h4 id="Preview_Action"><a href="#Preview_Action" class="headerlink" title="Preview Action"></a>Preview Action</h4><p>在 peek 弹出预览视图时,可以上滑显示几个按钮,让用户做一些快速操作.<br><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/iOS9_3D_Touch/Preview_Action.png" alt=""></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: - preview action</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PreviewViewController</span> </span>&#123;</span><br><span class="line">    <span class="preprocessor">@available</span>(iOS <span class="number">9.0</span>, *)</span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">previewActionItems</span><span class="params">()</span></span> -&gt; [<span class="type">UIPreviewActionItem</span>] &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">let</span> action1 = <span class="type">UIPreviewAction</span>(title: <span class="string">"action1"</span>, style: .<span class="type">Default</span>) &#123; (action, viewController) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">debugPrint</span>(action)</span><br><span class="line">            <span class="built_in">debugPrint</span>(viewController)</span><br><span class="line">            <span class="built_in">debugPrint</span>(<span class="string">"taped action1"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 会多一个 小勾勾 😊</span></span><br><span class="line">        <span class="keyword">let</span> action2 = <span class="type">UIPreviewAction</span>(title: <span class="string">"action2"</span>, style: .<span class="type">Selected</span>) &#123; <span class="number">_</span>,<span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">debugPrint</span>(<span class="string">"taped action2"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 会变红色</span></span><br><span class="line">        <span class="keyword">let</span> action3 = <span class="type">UIPreviewAction</span>(title: <span class="string">"action3"</span>, style: .<span class="type">Destructive</span>) &#123; <span class="number">_</span>,<span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">debugPrint</span>(<span class="string">"taped action3"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [action1, action2, action3]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Home_Screen_Quick_Action"><a href="#Home_Screen_Quick_Action" class="headerlink" title="Home Screen Quick Action"></a>Home Screen Quick Action</h4><p>3D Touch 还可以用在 App ICON 上. 按压会显示 Quick Action,当用户选择其中的 Action Item，App 启动并跳转到相应的界面.这一过程相当于在PC上面的右键快捷菜单的功能.<br><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/iOS9_3D_Touch/Home_Screen_Quick_Action.png" alt=""><br>Quick Action 主要分成 <code>静态快速选项(Static quick actions)</code> 和 <code>动态快速选项(Dynamic quick actions)</code>:</p>
<ul>
<li><code>动态快速选项(Dynamic quick actions)</code> 在用户第一次加载应用后可用。使用 UIApplicationShortcutItem、UIMutableApplicationShortcutItem 以及 UIApplicationShortcutIcon 类和相关的API来定义 动态快速选项 。使用 shortcutItems 属性来添加动态快速选项到应用共享的 UIApplication 对象中。</li>
<li><code>静态快速选项(Static quick actions)</code>: 当用户安装完应用后立即就能使用。在应用的 Info.plist 文件中的UIApplicationShortcutItems 数组中定义 静态快速选项。</li>
</ul>
<p>动态快速选项只需要在 <code>func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?)</code> 中添加相应的 <code>shortcutItems</code> 就可以了.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">addShortcutItems</span><span class="params">(application: UIApplication)</span></span> &#123;</span><br><span class="line">   <span class="keyword">guard</span> #available(iOS <span class="number">9.0</span>, *) <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 9.1 还有更多好玩的 icon type</span></span><br><span class="line">   <span class="keyword">let</span> itemIcon1 = <span class="type">UIApplicationShortcutIcon</span>(type: .<span class="type">Location</span>)</span><br><span class="line">   <span class="keyword">let</span> item1 = <span class="type">UIMutableApplicationShortcutItem</span>(type: <span class="string">"type1"</span>, localizedTitle: <span class="string">"itemIcon1"</span>, localizedSubtitle: <span class="literal">nil</span>, icon: itemIcon1, userInfo: <span class="literal">nil</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">let</span> itemIcon2 = <span class="type">UIApplicationShortcutIcon</span>(type: .<span class="type">Share</span>)</span><br><span class="line">   <span class="keyword">let</span> item2 = <span class="type">UIMutableApplicationShortcutItem</span>(type: <span class="string">"type2"</span>, localizedTitle: <span class="string">"itemIcon2"</span>, localizedSubtitle: <span class="literal">nil</span>, icon: itemIcon2, userInfo: <span class="literal">nil</span>)</span><br><span class="line">   </span><br><span class="line">   application.shortcutItems = [item1,item2]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 <code>func application(application: UIApplication, performActionForShortcutItem shortcutItem: UIApplicationShortcutItem, completionHandler: (Bool) -&gt; Void)</code> 中响应用户的操作,进行页面跳转</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@available</span>(iOS <span class="number">9.0</span>, *)</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, performActionForShortcutItem shortcutItem: UIApplicationShortcutItem, completionHandler: <span class="params">(Bool)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> handled = <span class="literal">false</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> shortcutItem.type == <span class="string">"type1"</span> &#123;</span><br><span class="line">       <span class="comment">// 处理页面跳转</span></span><br><span class="line">       handled = <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span> shortcutItem.type == <span class="string">"type1"</span> &#123;</span><br><span class="line">       handled = <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   completionHandler(handled)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态快速选项需要在info.plist中添加以下项：<br><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/iOS9_3D_Touch/Static_quick_actions.jpg" alt=""><br><strong>PS: 最多可以显示4个标签；静态标签优先级高于动态标签；</strong></p>
<h4 id="u68C0_u6D4B_u662F_u5426_u652F_u6301_3D_Touch"><a href="#u68C0_u6D4B_u662F_u5426_u652F_u6301_3D_Touch" class="headerlink" title="检测是否支持 3D Touch"></a>检测是否支持 3D Touch</h4><p>iOS 提供了 <code>forceTouchCapability</code> 用来判断 3D Touch 的可用性.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">ensure3DTouch</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">guard</span> #available(iOS <span class="number">9.0</span>, *) <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="built_in">debugPrint</span>(<span class="string">"只支持 iOS 9.0 以上版本"</span>)</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">guard</span> traitCollection.forceTouchCapability == .<span class="type">Available</span> <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="built_in">debugPrint</span>(<span class="string">"不支持 3D Touch"</span>)</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   registerForPreviewingWithDelegate(<span class="keyword">self</span>, sourceView: view)</span><br><span class="line">   <span class="built_in">debugPrint</span>(<span class="string">"支持 3D Touch"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="PS_3A__u5982_u679C_u624B_u5934_u6CA1_u6709_u652F_u6301_3D_Touch__u7684_u8BBE_u5907_2C_u53EF_u4EE5_u4F7F_u7528_SBShortcutMenuSimulator__u8FD9_u4E2A_u63D2_u4EF6_28_u9ED1_u79D1_u6280"><a href="#PS_3A__u5982_u679C_u624B_u5934_u6CA1_u6709_u652F_u6301_3D_Touch__u7684_u8BBE_u5907_2C_u53EF_u4EE5_u4F7F_u7528_SBShortcutMenuSimulator__u8FD9_u4E2A_u63D2_u4EF6_28_u9ED1_u79D1_u6280" class="headerlink" title="PS: 如果手头没有支持 3D Touch 的设备,可以使用 <a href=" https:="" github.com="" deskconnect="" sbshortcutmenusimulator"="">SBShortcutMenuSimulator</a> 这个插件(黑科技">PS: 如果手头没有支持 3D Touch 的设备,可以使用 <a href="https://github.com/DeskConnect/SBShortcutMenuSimulator" target="_blank" rel="external">SBShortcutMenuSimulator</a> 这个插件(黑科技</h6><p><a href="https://github.com/broccolii/3DTouchDemo" target="_blank" rel="external">Demo 地址</a></p>
]]></content:encoded>
      <comments>http://broccolii.github.io/2015/11/06/iOS9_3D_Touch/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[iOS9 中的 CoreSpotlight]]></title>
      <link>http://broccolii.github.io/2015/10/02/iOS9_CoreSpotlight/</link>
      <guid>http://broccolii.github.io/2015/10/02/iOS9_CoreSpotlight/</guid>
      <pubDate>Fri, 02 Oct 2015 00:52:23 GMT</pubDate>
      <description>
      <![CDATA[<p>Apple 发布了 iOS9 新系统,其中有一项新功能 <code>CoreSpotlight</code> 可以使 iPhone 的 Spotlight 访问 App 内的信息,在此之前只能通过 App 名来搜索 App.让我们来动手试一下.</p>
<h4 id="u4]]>
      </description>
      <content:encoded><![CDATA[<p>Apple 发布了 iOS9 新系统,其中有一项新功能 <code>CoreSpotlight</code> 可以使 iPhone 的 Spotlight 访问 App 内的信息,在此之前只能通过 App 名来搜索 App.让我们来动手试一下.</p>
<h4 id="u4F7F_u7528_CoreSpotlight"><a href="#u4F7F_u7528_CoreSpotlight" class="headerlink" title="使用 CoreSpotlight"></a>使用 CoreSpotlight</h4><p> <strong>导入 CoreSpotlight Framework</strong><br> 先导入 <code>CoreSpotlight.framework</code><br><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/iOS9_CoreSpotlight/CoreSpotlight.png" alt=""><br>和 <code>MobileCoreServices.framework</code><br><img src="https://github.com/broccolii/broccolii.github.io/raw/master/images/iOS9_CoreSpotlight/MobileCoreServices.png" alt=""><br><strong>创建索引数据</strong><br>先创建一个用户 UITableView 的数据 Model</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpotlightModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> image: <span class="type">UIImage</span>!</span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span>!</span><br><span class="line">    <span class="keyword">var</span> detailText: <span class="type">String</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">createRandomData</span>() -&gt; <span class="title">SpotlightModel</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> model = <span class="type">SpotlightModel</span>()</span><br><span class="line">        model.image = <span class="type">UIImage</span>(named: <span class="string">"image<span class="subst">\(arc4random()</span> % 3)"</span>)</span><br><span class="line">        model.detailText = <span class="string">"detailText<span class="subst">\(arc4random()</span> % 100)"</span></span><br><span class="line">        model.text = <span class="string">"text<span class="subst">\(arc4random()</span> % 300)"</span></span><br><span class="line">        <span class="keyword">return</span> model</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>将 <code>SpotlightModel</code> 对象保存到 CoreSpotlight 中</strong><br>创建我们需要被搜索到数据</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lazy var tableViewData: [SpotlightModel] = &#123;</span><br><span class="line">   var arr = [<span class="link_label">SpotlightModel</span>](<span class="link_url"></span>)</span><br><span class="line">   for _ in 0..<span class="xml"><span class="tag">&lt;<span class="title">30</span> &#123;</span><br><span class="line">       <span class="attribute">arr.append</span>(<span class="attribute">SpotlightModel.createRandomData</span>())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="attribute">return</span> <span class="attribute">arr</span></span><br><span class="line">&#125;()</span></span></span><br></pre></td></tr></table></figure>
<p>我们分别使用 <code>CSSearchableItem</code> 保存单个 model 对象的信息, 然后通过<code>CSSearchableItemAttributeSet</code> 这个集合类加入到 <code>CSSearchableIndex.defaultSearchableIndex()</code> 中去, 这样我们就可以通过 <code>CoreSpotlight</code>,搜索到我们提供的元数据了.</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func addToCoreSpotlight() &#123;</span><br><span class="line">   <span class="keyword">var</span> searchableItems = [CSSearchableItem]()</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span> model <span class="keyword">in</span> tableViewData &#123;</span><br><span class="line">       <span class="keyword">let</span> attri = CSSearchableItemAttributeSet(<span class="attribute">itemContentType</span>: kUTTypeMessage as String)</span><br><span class="line">       </span><br><span class="line">       attri.title = <span class="string">"title"</span> </span><br><span class="line">       attri.contentDescription = <span class="string">"contentDescription"</span></span><br><span class="line">       attri.thumbnailData = UIImageJPEGRepresentation(UIImage(<span class="attribute">named</span>: <span class="string">"image0"</span>)!, <span class="number">0.9</span>)</span><br><span class="line">       attri.supportsPhoneCall = <span class="literal">true</span></span><br><span class="line">       attri.supportsNavigation = <span class="literal">true</span></span><br><span class="line">       attri.phoneNumbers = [<span class="string">"phone"</span>]</span><br><span class="line">       attri.emailAddresses = [<span class="string">"email"</span>]</span><br><span class="line">       attri.keywords = [<span class="string">"keywords"</span>]</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">let</span> searchableItem = CSSearchableItem(<span class="attribute">uniqueIdentifier</span>: model.text, <span class="attribute">domainIdentifier</span>: <span class="string">"com.broccoli"</span>, <span class="attribute">attributeSet</span>: attri)</span><br><span class="line">       searchableItems.append(searchableItem)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   CSSearchableIndex.defaultSearchableIndex<span class="function"><span class="params">()</span>.<span class="title">indexSearchableItems</span><span class="params">(searchableItems)</span> &#123; <span class="params">(error)</span> -&gt;</span> Void <span class="keyword">in</span></span><br><span class="line">       debugPrint(error)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>uniqueIdentifier: 在应用程序中这个值是唯一的，由于这个可以用于索引的更新、删除索引是唯一的，推荐使用UUID或者是搜索的条目的主键。</li>
<li>domainIdentifier: 一个可选的标识符，用来表示item的域(domain)或者所有者，这个可能用一个账户的邮箱作为identifier来索引数据，并且当账户删除的时候可以根据这个来删除数据，一般情况下domainIdentifier应该是这种格式<account-id>.<mailbox-id>并且不能包含时间。</mailbox-id></account-id></li>
<li>expirationDate: 过期的日期，默认过期的日期是一个月</li>
</ol>
</blockquote>
<p><strong>响应用户点击事件</strong><br>现在运行一下程序搜索 <code>title</code> 是不是可以看到 App 中的数据.<br><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/iOS9_CoreSpotlight/ScreenShot.png" alt=""></p>
<p>但是点击之后我们只能到 App 的主页,我们可以在 <code>UIApplicationDelegate</code> 中通过 <code>SearchID</code> 自定义跳转到我们自定义的页面</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, continueUserActivity userActivity: NSUserActivity, restorationHandler: <span class="params">([AnyObject]?)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="type">SearchID</span> = userActivity.userInfo?[<span class="string">"kCSSearchableItemActivityIdentifier"</span>] <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line">   <span class="keyword">let</span> navigationController = (window?.rootViewController <span class="keyword">as</span>! <span class="type">UINavigationController</span>)</span><br><span class="line">   navigationController.popToRootViewControllerAnimated(<span class="literal">false</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;​</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/broccolii/SpotlightDemo" target="_blank" rel="external">Demo 地址</a></p>
]]></content:encoded>
      <comments>http://broccolii.github.io/2015/10/02/iOS9_CoreSpotlight/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[iOS 中的 UIView 和 CALayer]]></title>
      <link>http://broccolii.github.io/2015/04/21/iOS_UIView_CALayer/</link>
      <guid>http://broccolii.github.io/2015/04/21/iOS_UIView_CALayer/</guid>
      <pubDate>Tue, 21 Apr 2015 03:34:21 GMT</pubDate>
      <description>
      <![CDATA[<h3 id="UIView__u548C_CALayer"><a href="#UIView__u548C_CALayer" class="headerlink" title="UIView 和 CALayer"></a>UIView 和 CALayer</h3><p><str]]>
      </description>
      <content:encoded><![CDATA[<h3 id="UIView__u548C_CALayer"><a href="#UIView__u548C_CALayer" class="headerlink" title="UIView 和 CALayer"></a>UIView 和 CALayer</h3><p><strong>UIView 可以响应事件</strong><br>点进 UIView.h 文件,可以看到 UIView : UIResponder.UIView 是继承 UIResponder 的,在 iOS 中 UIResponder 做为响应系统中事件的传递者和处理者,提供了大量事件处理的接口,比如我们经常使用的:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(nullable <span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(nullable <span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(nullable <span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(nullable <span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(nullable <span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure>
<p>以及关于第一响应者的一些方法:</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> (<span class="constant">BOOL</span>)canBecomeFirstResponder;    <span class="regexp">//</span> default is <span class="constant">NO</span></span><br><span class="line"></span>-<span class="ruby"> (<span class="constant">BOOL</span>)becomeFirstResponder;</span><br><span class="line"></span>-<span class="ruby"> (<span class="constant">BOOL</span>)canResignFirstResponder;    <span class="regexp">//</span> default is <span class="constant">YES</span></span><br><span class="line"></span>-<span class="ruby"> (<span class="constant">BOOL</span>)resignFirstResponder;</span><br><span class="line"></span>-<span class="ruby"> (<span class="constant">BOOL</span>)isFirstResponder;</span></span><br></pre></td></tr></table></figure>
<p><strong>UIView 是 CALayer 的 delegate</strong><br>我们继续看 UIView.h 文件,找到 <code>layer</code> 属性.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">strong</span>)                 <span class="built_in">CALayer</span>  *layer;              <span class="comment">// returns view's layer. Will always return a non-nil value. view is layer's delegate</span></span><br></pre></td></tr></table></figure>
<p>注释中有一句 <strong>“view is layer’s delegate”</strong>,我们可以自定义一个 UIView 的子类 <code>CustomView</code> 并在 <code>- (void)drawRect:(CGRect)rect</code> 打断点,在左侧的可以看到 CustomView 作为一个 CALayerDelegate 出现,<br><img src="https://github.com/broccolii/broccolii.github.io/raw/master/images/iOS_UIView_CALayer/CALayerDelegate.png" alt=""></p>
<p><strong>两者的联系</strong><br>UIView 内容的绘制和显示都是靠 <code>layer</code> 属性提供,而视图的点击事件则是通过父类 UIResponder 来接收处理.两者之间的区别可以看一下<a href="http://www.jianshu.com/p/079e5cf0f014" target="_blank" rel="external">详解CALayer 和 UIView的区别和联系</a></p>
<h3 id="frame__u548C_bounds"><a href="#frame__u548C_bounds" class="headerlink" title="frame 和 bounds"></a>frame 和 bounds</h3><p>为了更好了理解 <code>frame</code> 和 <code>bounds</code>,我们先来看一下一张图:<br><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/iOS_UIView_CALayer/CAlayer_frame.jpg" alt=""></p>
<ol>
<li>UIView 的 center 直接调用 rootLayer 的 position </li>
<li>UIView 的 bounds 直接调用 rootLayer 的 bounds</li>
<li>UIView 的 frame 直接调用 rootLayer 的 frame</li>
<li>rootLayer 的 frame 又是 <code>anchorPoint</code>, <code>position</code>, <code>bounds</code>, <code>transform</code> 四个属性的派生属性<br>既然九九归一,最后都是这四个属性在影响着 frame 的大小.我们先从 <code>anchorPoint</code> 和 <code>position</code> 着手,因为 <code>position</code> 是 <code>anchorPoint</code> 在 superLayer 上的投影坐标.<br><strong>anchorPoint</strong><br><code>anchorPoint</code> (锚点) 顾名思义是一个固定点,在做 transform 时,会以 <code>anchorPoint</code> 作为固定点旋转.在 iOS 中,anchorPoint 的值是以相对 bounds 的比例值来确定的.默认是(0.5，0.5),如果觉得太抽象可以看下图:</li>
</ol>
<p><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/iOS_UIView_CALayer/layer_coords_anchorpoint_position_2x-2.png" alt=""><br><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/iOS_UIView_CALayer/anchorpoint2.jpg" alt=""></p>
<p><strong>position</strong><br><code>position</code> 的定义是 <code>The position in the superlayer that the anchor point of the layer&#39;s bounds rect is aligned t</code> position 是 layer 相对 superLayer 坐标空间的位置.我们可以想象一下,我们是一条很大很大的邮轮停在大西洋上,我们向陆地发送的坐标就是船锚的位置.船锚的位置只能是相对于船身来说的,类比 <code>anchorPoint 的值是以相对 bounds 的比例值来确定的</code>.是不是很好理解呢(捂脸逃<br>PS: 这有一篇更好的文章 <a href="http://wonderffee.github.io/blog/2013/10/13/understand-anchorpoint-and-position/" target="_blank" rel="external">彻底理解position与anchorPoint</a></p>
<p><strong>bounds</strong><br>bounds 分为两部分: origin 和 size.bounds.size 定义了图层的大小,bounds.origin 却并不表示图层的位置,而是定了内部坐标系的原点.那什么是内部坐标系的原点呢?指的是图层内部子图层的坐标系,就是说如果修改了 bounds.origin 的自身不会发生任何变化,但是在其内部的子图层会发生位移.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *lightGrayView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">lightGrayView<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:lightGrayView];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">UIView</span> *orangeView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">25</span>, <span class="number">25</span>, <span class="number">50</span>, <span class="number">50</span>)];</span><br><span class="line">orangeView<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line">[lightGrayView addSubview:orangeView];</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/iOS_UIView_CALayer/bounds_demo1.png" alt=""><br>修改 bounds 追加以下代码<br><code>lightGrayView.layer.bounds = CGRectMake(20, 20, 100, 100);</code><br><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/iOS_UIView_CALayer/bounds_demo2.png" alt=""></p>
<p><strong>transform</strong><br>为什么 <code>transform</code> 会影响 frame 呢? 让我们来动手试一下吧</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *redView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">redView<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:redView];</span><br><span class="line">redView<span class="variable">.transform</span> = <span class="built_in">CGAffineTransformMakeRotation</span>(M_PI_4);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"redView.frame : --- %@"</span>, <span class="built_in">NSStringFromCGRect</span>(redView<span class="variable">.frame</span>));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"redView.bounds : --- %@"</span>, <span class="built_in">NSStringFromCGRect</span>(redView<span class="variable">.bounds</span>));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"redView.layer.frame : --- %@"</span>, <span class="built_in">NSStringFromCGRect</span>(redView<span class="variable">.layer</span><span class="variable">.frame</span>));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"redView.layer.bounds : --- %@"</span>, <span class="built_in">NSStringFromCGRect</span>(redView<span class="variable">.layer</span><span class="variable">.frame</span>));</span><br></pre></td></tr></table></figure>
<p>输出如下:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redView.frame : --- <span class="expansion">&#123;&#123;<span class="number">79.289321881345259</span>, <span class="number">79.289321881345245</span>&#125;, &#123;<span class="number">141.42135623730951</span>, <span class="number">141.42135623730951</span>&#125;&#125;</span></span><br><span class="line">redView.bounds : --- <span class="expansion">&#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">100</span>, <span class="number">100</span>&#125;&#125;</span></span><br><span class="line">redView.layer.frame : --- <span class="expansion">&#123;&#123;<span class="number">79.289321881345259</span>, <span class="number">79.289321881345245</span>&#125;, &#123;<span class="number">141.42135623730951</span>, <span class="number">141.42135623730951</span>&#125;&#125;</span></span><br><span class="line">redView.layer.bounds : --- <span class="expansion">&#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">100</span>, <span class="number">100</span>&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>frame 的大小是一个包含了经过转换后的顶点的最小矩形,如下图灰框所示:<br><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/iOS_UIView_CALayer/transform_demo.png" alt=""></p>
<p>那么 frame 和这四个属性之间到底是什么关系呢? 在不考虑 transform 的情况下是(三角函数实在是太难了啊!摔:</p>
<blockquote>
<p>frame.origin.x = position.x - anchorPoint.x * bounds.size.width<br>frame.origin.y = position.y - anchorPoint.y * bounds.size.height<br>frame.size.width = bounds.size.width<br>frame.size.height = bounds.size.height</p>
</blockquote>
]]></content:encoded>
      <comments>http://broccolii.github.io/2015/04/21/iOS_UIView_CALayer/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Objective-C 中的 Runtime]]></title>
      <link>http://broccolii.github.io/2015/02/19/Objective-C_Runtime/</link>
      <guid>http://broccolii.github.io/2015/02/19/Objective-C_Runtime/</guid>
      <pubDate>Thu, 19 Feb 2015 08:31:53 GMT</pubDate>
      <description>
      <![CDATA[<h3 id="Runtime__u662F_u4EC0_u4E48"><a href="#Runtime__u662F_u4EC0_u4E48" class="headerlink" title="Runtime 是什么"></a>Runtime 是什么</h3><p>Obje]]>
      </description>
      <content:encoded><![CDATA[<h3 id="Runtime__u662F_u4EC0_u4E48"><a href="#Runtime__u662F_u4EC0_u4E48" class="headerlink" title="Runtime 是什么"></a>Runtime 是什么</h3><p>Objective-C 是基于 C 语言加入了面向对象特性和消息转发机制的动态语言,因此它尽可能地将一些工作从编译链接推迟到运行时.这意味着仅仅有编译器是不够的,还需要一套运行时系统来执行编译后的代码.这个运行时系统就是一个用 C 和汇编写的 Runtime 库,它是 Objective-C 作为一门动态语言的是基础.虽然这些特性在开发中使用的较少，但是理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言,合理的运用还能在系统层面上解决一些技术问题.<br>你可以<a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">这里</a>在下载到 Apple 维护的 Runtime 源码,开始我们的探索.</p>
<h3 id="Runtime_NSObject_/_Class"><a href="#Runtime_NSObject_/_Class" class="headerlink" title="Runtime NSObject / Class"></a>Runtime NSObject / Class</h3><p>我们打开刚刚下载的源码,选择 NSObject.h 这个文件.我们可以看到 NSObject 就是一个包含 isa 指针的结构体:</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="class"><span class="keyword">interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">Class</span> <span class="title">isa</span>  <span class="title">OBJC_ISA_AVAILABILITY</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 Objective-C 语言的内部,每一个对象都有一个名为 isa 的指针,指向该对象的类.每一个类描述了一系列它的实例的特点,包括成员变量的列表,成员函数的列表等.每一个对象都可以接受消息,而对象能够接收的消息列表是保存在它所对应的类中.</p>
</blockquote>
<p>我们现在去 runtime.h 中去看一下 Class 是怎么定义的.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_<span class="built_in">AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的变量是为了兼容 Objective-C 2.0 之前的版本 可以忽略</span></span><br><span class="line"><span class="preprocessor">#if !__OBJC2__</span></span><br><span class="line">    <span class="comment">// 父类</span></span><br><span class="line">    Class super_class                                        OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 类名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 类的版本信息 默认是 0</span></span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 类信息,供运行期间使用的位标示</span></span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 类的实例变量大小</span></span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 存储类的成员变量的链表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 方法定义的链表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 常用方法的缓存</span></span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 协议的链表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br></pre></td></tr></table></figure>
<p>你会发现 Class 类里居然只有一个 isa 指针,刚刚不是说了 isa 是指向该对象的类么?为什么类也会有 isa 呢?根据万物皆对象,其实 Class 也是一个对象, 那么他必须是另一个类的实例化对象,那么这个类就是 <code>元类</code>(metaclass).元类存储着类方法列表,元类的 isa 指针又指向了 <code>根元类</code>(root metaclass).<br>有一张关于 isa 和继承关系的图,可能会让大家理解的更清晰一些:<br><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/Objective-C_Runtime/class-diagram.jpg" alt=""></p>
<p>isa 指针的值是可以被动态修改.iOS 中的 KVO 的实现机制就是将被观察对象的 isa 指针指向一个中间类而不是我们所观察的类,这就是 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" target="_blank" rel="external">isa-swizzling</a>.</p>
<hr>
<p>虽然 Objective-C 2.0 没有暴露,object_class 更多的细节,我们仍然可以从 Objective-C 1.0 的定义中获取我们想要的信息.<br><em>Ivar</em> 表示类的成员变量</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="comment">// 成员变量的名字</span></span><br><span class="line">    <span class="keyword">char</span> *ivar_name                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 成员变量的类型</span></span><br><span class="line">    <span class="keyword">char</span> *ivar_type                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 成员变量在链表中的位置</span></span><br><span class="line">    <span class="keyword">int</span> ivar_offset                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">&#125;                                                            OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br></pre></td></tr></table></figure>
<p><em>Method</em> 表示类的方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">    <span class="comment">// 方法名</span></span><br><span class="line">    SEL method_name                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 静态方法 / 实例方法</span></span><br><span class="line">    <span class="keyword">char</span> *method_types                                       OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 方法实现 (函数指针)</span></span><br><span class="line">    IMP method_imp                                           OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">&#125;                                                            OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br></pre></td></tr></table></figure>
<p><em>IMP</em> 其实就是 <code>objc_sendMsg(receiver, selector, arg1, arg2, ...)</code> 的指针</p>
<h3 id="Runtime__u6D88_u606F_u5904_u7406_u673A_u5236"><a href="#Runtime__u6D88_u606F_u5904_u7406_u673A_u5236" class="headerlink" title="Runtime 消息处理机制"></a>Runtime 消息处理机制</h3><p>你是否想过 Objective-C 为什么把对象调用方法称作 <code>消息传递</code>(或 <code>发送消息</code>) (pass a message).其实编译器会将我们的 <code>[receiver selector]</code> 翻译成一个 C 函数调用</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">objc_msgSend</span><span class="params">(receiver, selector)</span></span></span><br></pre></td></tr></table></figure>
<p>也可以添上参数</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">objc_sendMsg</span><span class="params">(receiver, selector, arg1, arg2, ...)</span></span></span><br></pre></td></tr></table></figure>
<p>发送消息之后一般会经过下面几个步骤:</p>
<ol>
<li>通过 receiver 的 isa 指针找到它的 Class </li>
<li>在 Class 的 method list 找 selector </li>
<li>如果 Class 中没到 foo,继续往它的 superclass 中找 </li>
<li>一旦找到 selector 这个函数，就去执行它的实现IMP<br>下图展示了一个方法查找的流程图:</li>
</ol>
<p><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/Objective-C_Runtime/messaging.PNG" alt=""></p>
<p>如果每一个消息都经过这样一个传递链,其实效率是很低.因为 class 往往只有 20% 的函数会被经常调用,如果把经常被调用的函数缓存下来,那可以大大提高函数查询的效率.这也就是 objc_class 中另一个重要成员 objc_cache 做的事情,当再次收到 selector 消息的时候，可以直接在 cache 里找到，避免去遍历 objc_method_list.</p>
<h3 id="Runtime__u6D88_u606F_u8F6C_u53D1_u673A_u5236"><a href="#Runtime__u6D88_u606F_u8F6C_u53D1_u673A_u5236" class="headerlink" title="Runtime 消息转发机制"></a>Runtime 消息转发机制</h3><p>如果走完所有步骤,如果 selector 还是没有被找到会发生什么?程序会在运行时挂掉并抛出 unrecognized selector 的异常?其实在异常抛出前,Runtime 会给你三次拯救程序的机会：</p>
<ul>
<li>Method resolution // 动态方法解析</li>
<li>Fast forwarding        // 消息转发</li>
<li>Normal forwarding // 消息转发</li>
</ul>
<p><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/Objective-C_Runtime/Forwarding.png" alt=""><br><em>Method resolution</em><br>首先，Objective-C 运行时会调用 <code>+resolveInstanceMethod:</code> 或者 <code>+resolveClassMethod:</code>,让你有机会提供一个函数实现.如果你添加了函数并返回 YES,那运行时系统就会重新启动一次消息发送的过程.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSEL &#123;</span><br><span class="line">    <span class="keyword">if</span>(aSEL == <span class="keyword">@selector</span>(foo:))&#123;</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> class], aSEL, (IMP)fooMethod, <span class="string">"v@:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> fooMethod(<span class="keyword">id</span> obj, SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Doing foo"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 resolve 方法没有实现或者 return NO,就会进到下一步 <em>Message Forwarding</em>(消息转发)</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (id)<span class="string">forwardingTargetForSelector:</span>(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span>(aSelector == <span class="annotation">@selector</span>(<span class="string">foo:</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> alternateObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> <span class="string">forwardingTargetForSelector:</span>aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Normal forwarding</em> 你是最后一个实现方法的机会<br>首先它会发送 <code>-methodSignatureForSelector:</code> 消息获得函数的参数和返回值类型.如果 <code>-methodSignatureForSelector:</code> 返回 nil,Runtime 则会发出 <code>-doesNotRecognizeSelector:</code> 消息,程序这时也就挂掉了.<br>如果返回了一个函数签名,Runtime 就会创建一个 <code>NSInvocation</code> 对象并发送 <code>-forwardInvocation:</code> 消息给目标对象<br><code>NSInvocation</code> 实际上就是对一个消息的描述,包括 selector 以及参数等信息.所以你可以在 <code>-forwardInvocation:</code> 里修改传进来的 NSInvocation 对象，然后发送 -invokeWithTarget: 消息给它，传进去一个新的目标</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)<span class="string">methodSignatureForSelector:</span>(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    NSMethodSignature *methodSignature = [<span class="keyword">super</span> <span class="string">methodSignatureForSelector:</span>aSelector];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!methodSignature) &#123;</span><br><span class="line">        methodSignature = [NSMethodSignature <span class="string">signatureWithObjCTypes:</span><span class="string">"v@:*"</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> methodSignature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="typename">void</span>)<span class="string">forwardInvocation:</span>(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    MessageForwarding *messageForwarding = [MessageForwarding <span class="keyword">new</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([messageForwarding <span class="string">respondsToSelector:</span>anInvocation.selector]) &#123;</span><br><span class="line">        [anInvocation <span class="string">invokeWithTarget:</span>messageForwarding];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><em>Method Resolution</em>:由于Method Resolution不能像消息转发那样可以交给其他对象来处理,所以只适用于在原来的类中代替掉.<br><em>Fast Forwarding</em>:它可以将消息处理转发给其他对象,使用范围更广,不只是限于原来的对象.<br><em>Normal Forwarding</em>:它跟Fast Forwarding一样可以消息转发,但它能通过NSInvocation对象获取更多消息发送的信息,例如:target、selector、arguments和返回值等信息.</p>
<h3 id="Method_Swizzling"><a href="#Method_Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h3><p>Objective-C 中的 Method Swizzling 是一项异常强大的技术，它可以允许我们动态地替换方法的实现.当我们想修改系统提供的类时,我们能有什么办法呢？继承类并重写方法是一种可行的办法,但是并不能称为最优解.我们可以通过 Runtime 的 Method Swizzling,它通过交换两个 selector 的 IMP 从而达到<code>张冠李戴</code>的效.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Tracking</span>) </span></span><br><span class="line"> </span><br><span class="line">+ (<span class="keyword">void</span>)load &#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; </span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; </span><br><span class="line">        Class aClass = [<span class="keyword">self</span> class]; </span><br><span class="line"> </span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(viewWillAppear:); </span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(xxx_viewWillAppear:); </span><br><span class="line"> </span><br><span class="line">        Method originalMethod = class_getInstanceMethod(aClass, originalSelector); </span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">BOOL</span> didAddMethod = </span><br><span class="line">            class_addMethod(aClass, </span><br><span class="line">                originalSelector, </span><br><span class="line">                method_getImplementation(swizzledMethod), </span><br><span class="line">                method_getTypeEncoding(swizzledMethod)); </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (didAddMethod) &#123; </span><br><span class="line">            class_replaceMethod(aClass, </span><br><span class="line">                swizzledSelector, </span><br><span class="line">                method_getImplementation(originalMethod), </span><br><span class="line">                method_getTypeEncoding(originalMethod)); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#pragma mark - Method Swizzling</span></span><br><span class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123; </span><br><span class="line">    [<span class="keyword">self</span> xxx_viewWillAppear:animated]; </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"viewWillAppear: %@"</span>, <span class="keyword">self</span>); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>我们通过 Method Swizzling 替换掉了,系统原本的 <code>viewWillAppear</code>.</p>
<h3 id="Objective-C_Associated_Objects"><a href="#Objective-C_Associated_Objects" class="headerlink" title="Objective-C Associated Objects"></a>Objective-C Associated Objects</h3><p>我们可以用 Category 对已存在的类添加实例方法或类方法,而不适合添加额外的属性.我们可以使用Associated Objects 来给已存在的类 Category 添加自定义的属性.<br>Associated Objects提供三个API来向对象添加、获取和删除关联值：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT <span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy)</span><br><span class="line">OBJC_EXPORT <span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">    __OSX_<span class="built_in">AVAILABLE_STARTING</span>(__MAC_10_6, __IPHONE_3_1);</span><br><span class="line">OBJC_EXPORT <span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object)</span><br><span class="line">    __OSX_<span class="built_in">AVAILABLE_STARTING</span>(__MAC_10_6, __IPHONE_3_1);</span><br></pre></td></tr></table></figure>
<p>有一点需要注意的是 <code>objc_removeAssociatedObjects</code> 这个方法会 remove 掉所有该对象的 Associated Objects, 所以要谨慎使用.下面我们试着给 NSObject 添加一个 <code>associatedObject</code> 属性.<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSObject+AssociatedObject.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">AssociatedObject</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="keyword">id</span> associatedObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="comment">// NSObject+AssociatedObject.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">AssociatedObject</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setAssociatedObject:(<span class="keyword">id</span>)associatedObject</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(associatedObject), associatedObject, OBJC_ASSO<span class="built_in">CIATION_RETAIN_NONATOMIC</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)associatedObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>Associated Objects 的 key 要求是唯一并且是常量,而SEL是满足这个要求的,所以上面的采用隐藏参数 <code>_cmd</code> 作为 key.</p>
]]></content:encoded>
      <comments>http://broccolii.github.io/2015/02/19/Objective-C_Runtime/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[iOS 中的 RunLoop]]></title>
      <link>http://broccolii.github.io/2015/01/31/iOS_Runloop/</link>
      <guid>http://broccolii.github.io/2015/01/31/iOS_Runloop/</guid>
      <pubDate>Fri, 30 Jan 2015 18:11:12 GMT</pubDate>
      <description>
      <![CDATA[<p>最近听了 <a href="http://blog.sunnyxx.com/" target="_blank" rel="external">sunnyxx</a> 大神关于 RunLoop 的分享会,总结一下 iOS 中的 RunLoop.</p>
<h3 id="u4E]]>
      </description>
      <content:encoded><![CDATA[<p>最近听了 <a href="http://blog.sunnyxx.com/" target="_blank" rel="external">sunnyxx</a> 大神关于 RunLoop 的分享会,总结一下 iOS 中的 RunLoop.</p>
<h3 id="u4EC0_u4E48_u662F_RunLoop"><a href="#u4EC0_u4E48_u662F_RunLoop" class="headerlink" title="什么是 RunLoop"></a>什么是 RunLoop</h3><p>RunLoop 顾名思义指的是运行的循环,指一个事件处理的循环,用来不停地调动工作以及处理输入事件.通俗点说RunLoop 好比一个 While 循环,不停地在监听事件,处理事件.不过 Apple 在此基础上进行了大量优化,使得大大减少了 CPU 的占用.比如给 RunLoop 添加了不同事件源,不同的 mode,使其在不工作时休眠等.不过 RunLoop 并不是 iOS / OS X 所特有的,在任何平台的多线程编程中,为了处理异步消息,都有这样一个类似消息队列的概念,比如 Android 中的 Looper.</p>
<h3 id="RunLoop__u548C_u7EBF_u7A0B_u7684_u5173_u7CFB"><a href="#RunLoop__u548C_u7EBF_u7A0B_u7684_u5173_u7CFB" class="headerlink" title="RunLoop 和线程的关系"></a>RunLoop 和线程的关系</h3><p>RunLoop 和 iOS 的线程是紧密相连的,在 iOS 中任何线程,如果要监听处理一些事件都需要产生一个 RunLoop 的对象.主线程中的 RunLoop 在 App 启动时产生并运行,子线程中需要手动创建并运行(<code>[NSRunLoop currentRunLoop];</code> 会判断是否有 RunLoop ,而自动创建).也就是说每一个线程中都可以获取 RunLoop 对象，但是并不是每一个线程中都有 RunLoop 的实例对象.</p>
<h3 id="RunLoop_mode"><a href="#RunLoop_mode" class="headerlink" title="RunLoop mode"></a>RunLoop mode</h3><p>RunLoop 运行时,它会显式或隐式地指定一个mode.并只能以一种固定的模式运行,只会监听这个 mode 下添加的 Time Source 和 Input Source.如果这个模式下没有添加事件源,RunLoop会立刻退出.大多数时候,Run Loop 都是运行在系统定义的默认模式上.同理也只有与这个 mode 关联的 observer 才会被通知.和其他 mode 关联的事件源只有当 Run Loop 运行在对应的 mode 下才会分发相应的事件过来，否则就处于暂停状态。<br>在 Cocoa 中定义的 mode 主要的是那么几种:</p>
<blockquote>
<ol>
<li>CFRunLoopDefaultMode: 这个是默认 mode,也是空闲状态.主线程通常在这个 mode 下运行的</li>
<li>UITrackingRunLoopMode: 当 ScrollView 滚动时候的模式</li>
<li>UIInitializationRunLoopMode: 在刚启动程序时进入的第一个 mode,启动完成后就不再使用</li>
<li>GSEventReceiveRunLoopMode: 接受系统事件的内部的 mode</li>
<li>CFRunLoopCommonModes: 这是一个集合,包含了 1,2 两种模式</li>
</ol>
</blockquote>
<p>需要注意的是 CFRunLoopCommonModes 其实并不是一种 mode,而是一个集合.因此 RunLoop 并不能在CFRunLoopCommonModes下运行.但是你可以将需要输入的事件源添加为这个 mode,这样无论 RunLoop 运行在哪个 mode 下都可以响应这个输入事件,否则这个事件将不会得到响应.</p>
<p>这里我们可能会遇到一些 RunLoop 的坑:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSTimer <span class="string">scheduledTimerWithTimeInterval:</span><span class="number">1.0</span> <span class="string">target:</span>self <span class="string">selector:</span><span class="annotation">@selector</span>(foo) <span class="string">userInfo:</span>nil <span class="string">repeats:</span>YES];</span><br></pre></td></tr></table></figure>
<p>一般情况下我们会使用这个方法来添加一个定时器,但是我们用这个方法创建的 NSTimer 会被加到 CFRunLoopDefaultMode 中,此时,如果页面开始滚动 主线程 RunLoop 的 mode 会切换到 UITrackingRunLoopMode,我们刚刚创建的 NSTimer 就不会运行.我们可以将新建的 NSTimer 放到<br> CFRunLoopCommonModes 中,这样不论在什么状态都是可以执行的.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *timer = [NSTimer <span class="string">timerWithTimeInterval:</span><span class="number">1.0</span> <span class="string">target:</span>self <span class="string">selector:</span><span class="annotation">@selector</span>(foo) <span class="string">userInfo:</span>nil <span class="string">repeats:</span>YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] <span class="string">addTimer:</span>timer <span class="string">forMode:</span>NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>
<h3 id="RunLoop_sources"><a href="#RunLoop_sources" class="headerlink" title="RunLoop sources"></a>RunLoop sources</h3><p>下图展示了 RunLoop 的模型: 可以看出 RunLoop 是线程中的一个循环,并接收两个事件源的消息:<br>Input sources 和 Timer sources<br><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg" alt=""><br><strong>Input sources:</strong><br>Input source 用来投递异步消息,通常消息来自另外的线程或者程序.<br>消息类型分为以下三种:</p>
<p><em>1) Port Input Source</em></p>
<p>Cocoa 和 Core Foundation 提供了 Mach Port 用于线程或进程间的通信.<br>如果要建立和 NSMachPort 对象的本地连接,你需要创建端口对象并加入主线程的 RunLoop 里.当运行子线程的时候,你传递端口对象到子线程的入口.子线程通过端口对象将消息传入主线程.</p>
<p>首先在主线程建立端口对象,并在次线程的启动时将端口对象传入:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置主线程 port,子线程通过此端口发送消息给主线程</span></span><br><span class="line"><span class="built_in">NSPort</span> *myPort = [<span class="built_in">NSMachPort</span> port];</span><br><span class="line"><span class="keyword">if</span> (myPort) &#123;</span><br><span class="line">    myPort<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:myPort forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动子线程,并传入端口信息</span></span><br><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(launchThreadWithPort:) toTarget:	 [MyWorkerClass class] withObject:myPort];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>2) Cocoa Perform Selector Sources</em></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>performSelectorOnMainThread:<span class="params">(<span class="variable">SEL</span>)</span>aSelector withObject:<span class="params">(nullable id)</span>arg waitUntilDone:<span class="params">(<span class="variable">BOOL</span>)</span>wait modes:<span class="params">(nullable <span class="variable">NSArray</span>&lt;<span class="variable">NSString</span> *&gt; *)</span>array;</span><br><span class="line">- <span class="params">(void)</span>performSelectorOnMainThread:<span class="params">(<span class="variable">SEL</span>)</span>aSelector withObject:<span class="params">(nullable id)</span>arg waitUntilDone:<span class="params">(<span class="variable">BOOL</span>)</span>wait;</span><br><span class="line">- <span class="params">(void)</span>performSelector:<span class="params">(<span class="variable">SEL</span>)</span>aSelector onThread:<span class="params">(<span class="variable">NSThread</span> *)</span>thr withObject:<span class="params">(nullable id)</span>arg waitUntilDone:<span class="params">(<span class="variable">BOOL</span>)</span>wait modes:<span class="params">(nullable <span class="variable">NSArray</span>&lt;<span class="variable">NSString</span> *&gt; *)</span>array NS_AVAILABLE<span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span>;</span><br><span class="line">- <span class="params">(void)</span>performSelector:<span class="params">(<span class="variable">SEL</span>)</span>aSelector onThread:<span class="params">(<span class="variable">NSThread</span> *)</span>thr withObject:<span class="params">(nullable id)</span>arg waitUntilDone:<span class="params">(<span class="variable">BOOL</span>)</span>wait NS_AVAILABLE<span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span>;</span><br><span class="line">- <span class="params">(void)</span>performSelector:<span class="params">(<span class="variable">SEL</span>)</span>aSelector withObject:<span class="params">(nullable id)</span>anArgument afterDelay:<span class="params">(<span class="variable">NSTimeInterval</span>)</span>delay inModes:<span class="params">(<span class="variable">NSArray</span>&lt;<span class="variable">NSString</span> *&gt; *)</span>modes;</span><br><span class="line">- <span class="params">(void)</span>performSelector:<span class="params">(<span class="variable">SEL</span>)</span>aSelector withObject:<span class="params">(nullable id)</span>anArgument afterDelay:<span class="params">(<span class="variable">NSTimeInterval</span>)</span>delay;</span><br><span class="line">+ <span class="params">(void)</span>cancelPreviousPerformRequestsWithTarget:<span class="params">(id)</span>aTarget selector:<span class="params">(<span class="variable">SEL</span>)</span>aSelector object:<span class="params">(nullable id)</span>anArgument;</span><br><span class="line">+ <span class="params">(void)</span>cancelPreviousPerformRequestsWithTarget:<span class="params">(id)</span>aTarget;</span></span><br></pre></td></tr></table></figure>
<p>这些 API 中,最后两个是取消当前线程中的 aSelector 调用,其他的 API 是在当前线程执行指定的 aSelector</p>
<p><strong>Timer source:</strong></p>
<p>Timer Source 类型的事件源,就是创建Timer添加到RunLoop中.在Cocoa里,使用NSTimer创建定时器加入 RunLoop,在 Core Foundation 里使用 CFRunLoopTimerRef 类型,本质上 NSTimer 是CFRunLoopTimerRef的简单扩展.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *timer = [NSTimer <span class="string">timerWithTimeInterval:</span><span class="number">1.0</span> <span class="string">target:</span>self <span class="string">selector:</span><span class="annotation">@selector</span>(foo) <span class="string">userInfo:</span>nil <span class="string">repeats:</span>YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] <span class="string">addTimer:</span>timer <span class="string">forMode:</span>NSRunLoopCommonModes]</span><br></pre></td></tr></table></figure>
<h3 id="RunLoop_Observer"><a href="#RunLoop_Observer" class="headerlink" title="RunLoop Observer"></a>RunLoop Observer</h3><p>对比上面说的 sources,它们是在特定的同步事件或异步事件发生时被触发,RunLoop observer 就不一样了,它是在 RunLoop 执行自己的代码到某一个指定状态时被触发.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>),</span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>),</span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>),</span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">5</span>),</span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">6</span>),</span><br><span class="line">    kCFRunLoopExit = (<span class="number">1U</span>L &lt;&lt; <span class="number">7</span>),</span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopObserverContext</span>  context = &#123;<span class="number">0</span>, (__bridge <span class="keyword">void</span> *)(<span class="keyword">self</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreate</span>(k<span class="built_in">CFAllocatorDefault</span>, k<span class="built_in">CFRunLoopBeforeTimers</span>, <span class="literal">YES</span>, <span class="number">0</span>, &amp;runLoopObserver, &amp;context);</span><br><span class="line"><span class="keyword">if</span> (observer) &#123;</span><br><span class="line">	<span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), observer, k<span class="built_in">CFRunLoopCommonModes</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://broccolii.github.io/2015/01/31/iOS_Runloop/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[iOS 中的多线程]]></title>
      <link>http://broccolii.github.io/2014/09/29/iOS_multithreading/</link>
      <guid>http://broccolii.github.io/2014/09/29/iOS_multithreading/</guid>
      <pubDate>Mon, 29 Sep 2014 15:56:35 GMT</pubDate>
      <description>
      <![CDATA[<p>整理了一下 iOS 开发中会遇到的几种多线程.</p>
<h3 id="iOS__u4E2D_u7684_u591A_u7EBF_u7A0B_u7F16_u7A0B"><a href="#iOS__u4E2D_u7684_u591A_u7EBF_u7A0B_u7F16_u7]]>
      </description>
      <content:encoded><![CDATA[<p>整理了一下 iOS 开发中会遇到的几种多线程.</p>
<h3 id="iOS__u4E2D_u7684_u591A_u7EBF_u7A0B_u7F16_u7A0B"><a href="#iOS__u4E2D_u7684_u591A_u7EBF_u7A0B_u7F16_u7A0B" class="headerlink" title="iOS 中的多线程编程"></a>iOS 中的多线程编程</h3><p>iOS 中的多线程分为以下三种: NSThread, NSOperation/NSOperationQueue, GCD. 其中 NSOperation/NSOperationQueue 是对 GCD 的面向对象封装.</p>
<h3 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h3><h3 id="u7EBF_u7A0B_/__u8FDB_u7A0B"><a href="#u7EBF_u7A0B_/__u8FDB_u7A0B" class="headerlink" title="线程 / 进程"></a>线程 / 进程</h3><ul>
<li>进程(Process):操作系统进行资源分配和调度的基本单位,计算机中已运行程序的实体.</li>
<li>线程(thread):操作系统进行运算调度的最小单位,它被包含在进程之中,是进程中的实际运作单位.一个进程中至少包含一条线程,即主线程.</li>
</ul>
<h4 id="u540C_u6B65_/__u5F02_u6B65"><a href="#u540C_u6B65_/__u5F02_u6B65" class="headerlink" title="同步 / 异步"></a>同步 / 异步</h4><ul>
<li>同步:同步操作会等待操作执行完成后,再继续执行接下来的代码.(会堵塞当前线程)    </li>
<li>异步:异步操作在调用后立即返回,不会等待操作的执行结果.(不会堵塞当前线程)</li>
</ul>
<h4 id="u4E32_u884C_u961F_u5217_/__u5E76_u884C_u961F_u5217"><a href="#u4E32_u884C_u961F_u5217_/__u5E76_u884C_u961F_u5217" class="headerlink" title="串行队列 / 并行队列"></a>串行队列 / 并行队列</h4><ul>
<li>队列: 队列 (queue),是先进先出（FIFO, First-In-First-Out）的线性表.</li>
<li>串行队列: 串行队列是指队列中的任务是按照先后顺序一个接一个地执行的,队首的任务执行后才会执行其后的任务,直至执行到队尾的任务.</li>
<li>并行队列:并行队列是指队列中的任务可以同时地执行,即开始执行队首的任务后,不必等其执行完毕就可以接着开始执行队首之后的任务,因此在某一时刻可能存在同时执行的多个任务.</li>
</ul>
<p><strong>在串行队列中进行异步操作,会发生什么?</strong></p>
<blockquote>
<ol>
<li>加入的串行队列是手动创建的,那么会另开线程执行,从而不会堵塞当前线程.</li>
<li>如果加入的是当前线程的串行队列,那么会堵塞当前线程.比如: 将异步操作放到 main 队列(通过 GCD 的 <code>dispatch_get_main_queue()</code> 获取).</li>
</ol>
</blockquote>
<p><strong>在并行队列中进行同步操作,会发生什么?</strong><br>直接堵塞当前线程,直至同步操作执行完.</p>
<p>详细细节请看<a href="http://www.cnblogs.com/dsxniubility/p/4296937.html" target="_blank" rel="external">董铂然的Blog</a><br>下图表<a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/GCD扫盲篇.md" target="_blank" rel="external">引用自 ChenYilong 的 GCD 扫盲篇</a></p>
<table>
<thead>
<tr>
<th>—</th>
<th>同步</th>
<th>异步 </th>
</tr>
</thead>
<tbody>
<tr>
<td>串行队列</td>
<td>不会新建线程，依然在当前线程上<p></p>类似同步锁，是同步锁的替代方案<p></p>✅ 常用</td>
<td>会新建线程，只开一条线程<p></p>一条线程就够了<p></p> 每次使用 createDispatch 方法就会新建一条线程，多次调用该方法，会创建多条线程，多条线程间会并行执行</td>
</tr>
<tr>
<td>并行队列</td>
<td>不会新建线程，依然在当前线程上<p></p></td>
<td>会新建线程，可以开多条线程<p></p> iOS7-SDK 时代一般是5、6条， iOS8-SDK 以后可以50、60条 <p></p> ✅ 常用</td>
</tr>
</tbody>
</table>
<h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><p>在 iOS 中使用 NSThread 对象建立一个线程非常方便,但是线程的生命周期需要程序员手动管理,也不便于管理多个线程.<br><strong>创建&amp;启动</strong><br><em>两种显式调用</em><br>1.实例方法</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSThread *thread = [[NSThread alloc] <span class="string">initWithTarget:</span>self <span class="string">selector:</span><span class="annotation">@selector</span>(<span class="string">doSomething:</span>) <span class="string">object:</span>nil];</span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure>
<p>2.类方法</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSThread <span class="string">detachNewThreadSelector:</span><span class="annotation">@selector</span>(<span class="string">doSomething:</span>) <span class="string">toTarget:</span>self <span class="string">withObject:</span>nil];</span><br></pre></td></tr></table></figure>
<p><em>隐式调用</em></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self <span class="string">performSelectorInBackground:</span><span class="annotation">@selector</span>(<span class="string">doSomething:</span>) <span class="string">withObject:</span>nil];</span><br></pre></td></tr></table></figure>
<p><strong>一些常用的方法</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得当前线程</span></span><br><span class="line">+ (<span class="built_in">NSThread</span> *)currentThread;</span><br><span class="line"><span class="comment">// 线程休眠</span></span><br><span class="line">+ (<span class="keyword">void</span>)sleepForTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti;</span><br><span class="line"><span class="comment">// 获取主线程</span></span><br><span class="line">+ (<span class="built_in">NSThread</span> *)mainThread;</span><br><span class="line"><span class="comment">// 判断当前线程是否主线程</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isMainThread;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)isMainThread;</span><br><span class="line"><span class="comment">// 判断线程是否正在运行</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isExecuting;</span><br><span class="line"><span class="comment">// 判断线程是否已结束</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isFinished;</span><br></pre></td></tr></table></figure>
<h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>GCD 指的是 Grand Central Dispatch, 是 Apple 提供的一个多核编程的解决方案.GCD 是基于 C 语言的框架,可以充分利用多核,是 Apple 推荐使用的多线程技术.他不需要像 NSThread 一样需要手动管理线程的生命周期,它会自动管理.<br><strong>GCD 中的队列</strong></p>
<ul>
<li>串行队列</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"serialQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure>
<ul>
<li>并行队列</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"concurrentQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>
<p>还有两个特殊的队列:</p>
<ul>
<li>main 队列(串行队列)</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t mainQueue = <span class="function"><span class="title">dispatch_get_main_queue</span><span class="params">()</span></span>；</span><br></pre></td></tr></table></figure>
<p>和 NSThread 中的 <code>+ (NSThread *)mainThread;</code> 一样,用于获取 main 队列, 即 当前进程的主线程.</p>
<blockquote>
<p>在主队列里面执行同步执行任务会造成死锁现象 <a href="http://www.brighttj.com/ios/ios-gcd-deadlock.html" target="_blank" rel="external">详情请看</a></p>
</blockquote>
<ul>
<li>全局队列(并行队列)<br>GCD 默认已经提供了全局的并发队列,供整个应用使用,不需要手动创建.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认权限的 全局队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> defaultQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 有以下几种权限</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_HIGH <span class="number">2</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_DEFAULT <span class="number">0</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_LOW (-<span class="number">2</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span></span><br></pre></td></tr></table></figure>
<p><strong>GCD 的同步/异步</strong><br>在 默认权限下的全局队列 中执行 同步操作</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync<span class="list">(<span class="keyword">dispatch_get_global_queue</span><span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span>, ^&#123;</span><br><span class="line">        // 同步执行的代码</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>在 默认权限下的全局队列 中执行 异步操作</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async<span class="list">(<span class="keyword">dispatch_get_global_queue</span><span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span>, ^&#123;</span><br><span class="line">        // 异步执行的代码</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>dispatch_once</strong><br><code>dispatch_once</code> 保证在 App 运行期间,block 中的代码只执行一次.<br>一般用在实现单例模式上:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例模式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> _instance;</span><br><span class="line"></span><br><span class="line">+ (instancetype)sharedSingleton&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _instance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)allocWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _instance = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone&#123;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>dispatch_after</strong><br><code>dispatch_after</code> 延迟一段时间把一项任务提交到队列中执行,这里需要注意的是: 延时的操作是提交,而不是运行.</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">dispatch_after</span>(<span class="function">dispatch_time</span>(DISPATCH_TIME_NOW, (int64_t)(<span class="number">10</span> * NSEC_PER_SEC)), <span class="tag">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">        <span class="comment">// 延迟操作的代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>dispatch_group</strong><br>我们使用 <code>group</code> 来管理一组异步代码,当它们都执行完后会调用同步或者异步(<code>dispatch_group_notify</code>)回调通知我们.</p>
<p><em>异步回调</em></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">   <span class="comment">// 异步执行的代码</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">   <span class="comment">// 异步执行的代码</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">   <span class="comment">// 异步执行的代码</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(<span class="keyword">group</span>, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">   <span class="comment">// 当所有异步执行的代码执行完毕会进入</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><em>同步回调</em></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">   <span class="comment">// 异步执行的代码</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">   <span class="comment">// 异步执行的代码</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">   <span class="comment">// 异步执行的代码</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_wait(<span class="keyword">group</span>, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>
<p>注: <code>dispatch_group_wait</code> 第二个参数表示超时时间. <code>DISPATCH_TIME_FOREVER</code> 表示没有超时时间.</p>
<p><strong>dispatch_apply</strong><br><code>dispatch_apply</code> 用于重复执行同一个任务,以同步的方式把任务追加到队列当中.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">dispatch_apply(<span class="number">3</span>, <span class="built_in">queue</span>, ^(<span class="keyword">size_t</span> index) &#123;</span><br><span class="line">   NSLog(@<span class="string">"%zu"</span>, index);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">01</span>-<span class="number">08</span> <span class="number">18</span>:<span class="number">07</span>:<span class="number">35.923</span> MultithreadingDemo[<span class="number">5626</span>:<span class="number">397563</span>] <span class="number">0</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">01</span>-<span class="number">08</span> <span class="number">18</span>:<span class="number">07</span>:<span class="number">35.923</span> MultithreadingDemo[<span class="number">5626</span>:<span class="number">397617</span>] <span class="number">1</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">01</span>-<span class="number">08</span> <span class="number">18</span>:<span class="number">07</span>:<span class="number">35.923</span> MultithreadingDemo[<span class="number">5626</span>:<span class="number">397831</span>] <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>dispatch_suspend &amp; dispatch_resume</strong><br><code>dispatch_suspend</code> 用于暂停队列<br><code>dispatch_resume</code> 用于恢复队列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 挂起指定的队列</span></span><br><span class="line">dispatch_suspend(<span class="built_in">queue</span>);</span><br><span class="line"><span class="comment">// 恢复指定队列</span></span><br><span class="line">dispatch_resume(<span class="built_in">queue</span>);</span><br></pre></td></tr></table></figure>
<h3 id="NSOperation/NSOperationQueue"><a href="#NSOperation/NSOperationQueue" class="headerlink" title="NSOperation/NSOperationQueue"></a>NSOperation/NSOperationQueue</h3><p>NSOperation/NSOperationQueue 是 Apple 对 GCD 的封装,一个建立在 GCD 的基础之上的,面向对象的解决方案.相对 GCD 来说,使用 NSOperation/NSOperationQueue 会增加一点点额外的开销,与此同时也也获得了更好的灵活性.我们可以指定各个 NSOperation 之间的依赖关系,也可以继承 NSOperation 实现可复用的逻辑模块.</p>
<p><strong>NSOperation</strong><br>NSOperation 用来表示一个需要执行的任务.NSOperation 本身是一个抽象类,不能直接实例化,但是系统提供了两个子类用于封装任务.分别是: NSInvocationOperation 和 NSBlockOperation,同时也可以自定义子类.创建一个 NSOperation 对象后,需要调用 start 方法来启动任务,需要注意的是它会默认在当前队列同步执行.</p>
<ul>
<li>NSInvocationOperation<br>通过一个 object 和 selector 我们可以非常方便地创建一个 NSInvocationOperation.</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInvocationOperation</span> *operation = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(doSomething) object:<span class="literal">nil</span>];</span><br><span class="line">[operation start];</span><br></pre></td></tr></table></figure>
<ul>
<li>NSBlockOperation<br>我们可以使用  NSBlockOperation 来并发执行一个或多个 block. 可以通过NSBlockOperation的实例方法 <code>addExecutionBlock</code> 实现类似 GCD 中的 <code>dispatch_group</code> 的功能.</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> *operation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">   <span class="comment">// do something</span></span><br><span class="line">&#125;];</span><br><span class="line">[operation start];</span><br></pre></td></tr></table></figure>
<p><em>使用有 NSOperation 有什么灵活性呢?</em><br>1.依赖关系<br>NSOperation 有一个非常实用的功能,那就是添加依赖.它可以让一个 operation 只有在它依赖的所有 operation 都执行完成后才能开始执行.</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>addDependency:<span class="params">(<span class="variable">NSOperation</span> *)</span>op;</span></span><br></pre></td></tr></table></figure>
<p>2.队列中的优先级<br>对于被添加到 queue 中的 operation 来说，在 isReady(取决于依赖关系) 状态下,决定它们执行顺序他们在队列中的优先级.默认情况下都是 normal 的,但是我们可以根据需要通过 <code>setQueuePriority:</code> 方法来提高或降低 operation 的队列优先级.有以下几种优先级给我们选择.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">NSOperationQueuePriority</span>) &#123;</span><br><span class="line">	<span class="built_in">NSOperationQueuePriorityVeryLow</span> = -<span class="number">8</span>L,</span><br><span class="line">	<span class="built_in">NSOperationQueuePriorityLow</span> = -<span class="number">4</span>L,</span><br><span class="line">	<span class="built_in">NSOperationQueuePriorityNormal</span> = <span class="number">0</span>,</span><br><span class="line">	<span class="built_in">NSOperationQueuePriorityHigh</span> = <span class="number">4</span>,</span><br><span class="line">	<span class="built_in">NSOperationQueuePriorityVeryHigh</span> = <span class="number">8</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>3.可以在任务执行完进行回调</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[operation1 <span class="built_in">set</span>CompletionBlock:^&#123;</span><br><span class="line">    // <span class="keyword">do</span> something  </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><strong>NSOperationQueue</strong><br>NSOperationQueue 并不像 GCD 中的队列那么复杂.默认都是并行的,通过设置 NSOperationQueue 的 <code>maxConcurrentOperationCount</code> 属性为一.那么它就变成了串行队列.NSOperationQueue 提供了获取 main 队列的方法.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (NSOperationQueue *)<span class="function">mainQueue <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_6, <span class="number">4</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p>不过一般情况下我们会使用 </p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue = <span class="comment">[<span class="comment">[NSOperationQueue alloc]</span> init]</span>;</span><br></pre></td></tr></table></figure>
<p>进行初始化创建,然后通过以下三种方法添加任务,如果使用了下面三个方法,那么自动执行了 NSOperation 的 <code>start</code> 方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加一个NSOperation</span></span><br><span class="line">- (<span class="keyword">void</span>)addOperation:(NSOperation *)op;</span><br><span class="line"><span class="comment">// 添加一组NSOperation</span></span><br><span class="line">- (<span class="keyword">void</span>)addOperations:(NSArray&lt;NSOperation *&gt; *)ops waitUntilFinished:(BOOL)<span class="function">wait <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_6, <span class="number">4</span>_0)</span></span>;</span><br><span class="line"><span class="comment">// 以 block 的形式 添加任务(代替 NSBlockOperation)</span></span><br><span class="line">- (<span class="keyword">void</span>)addOperationWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))<span class="function">block <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_6, <span class="number">4</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://broccolii.github.io/2014/09/29/iOS_multithreading/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Objective-C 中的 Block]]></title>
      <link>http://broccolii.github.io/2014/07/28/Objective-C_Block/</link>
      <guid>http://broccolii.github.io/2014/07/28/Objective-C_Block/</guid>
      <pubDate>Sun, 27 Jul 2014 17:11:02 GMT</pubDate>
      <description>
      <![CDATA[<h3 id="u4EC0_u4E48_u662F_Block"><a href="#u4EC0_u4E48_u662F_Block" class="headerlink" title="什么是 Block"></a>什么是 Block</h3><p>Block 翻译成中文就是块]]>
      </description>
      <content:encoded><![CDATA[<h3 id="u4EC0_u4E48_u662F_Block"><a href="#u4EC0_u4E48_u662F_Block" class="headerlink" title="什么是 Block"></a>什么是 Block</h3><p>Block 翻译成中文就是块,顾名思义指的是代码块.与函数类似,有参数,有返回值.只不过是直接实现在另一个函数里的,同时可以获取该函数的局部变量. Block 只是 Objective-C 对闭包的实现.</p>
<blockquote>
<p>讲人话:  Block 就是一段能够在将来被执行的代码. Block 本身就是一个普通的 Objective-C 对象.正因为它是对象，Block 可以被作为参数传递，可以作为返回值从一个方法返回，可以用来给变量赋值</p>
</blockquote>
<h3 id="Block__u7684_u7533_u660E_u5B9A_u4E49"><a href="#Block__u7684_u7533_u660E_u5B9A_u4E49" class="headerlink" title="Block 的申明定义"></a>Block 的申明定义</h3><p>可以先看一下 <a href="http://fuckingblocksyntax.com" target="_blank" rel="external">How Do I Declare A Block in Objective-C?</a><br>Block 的声明格式如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">returnType (^blockName)(parameterTypes) = ^returnType(parameters) <span class="decorator">&#123;...&#125;</span>;</span><br></pre></td></tr></table></figure>
<p>我们实现一个加法功能的 Block</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (^addBlock)(<span class="keyword">int</span> a, <span class="keyword">int</span> b) = ^(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">   <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后像函数一样调用这个 Block </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> add = addBlock(<span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Block__u7684_u53D8_u91CF"><a href="#Block__u7684_u53D8_u91CF" class="headerlink" title="Block 的变量"></a>Block 的变量</h3><p>还记得我们刚刚说过 Block 会获取实现它的函数内的局部变量,并且对这些栈变量进行一次只读拷贝，然后在  Block 块内使用该只读拷贝.</p>
<ol>
<li>只读: 不能被修改值</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)foo &#123;</span><br><span class="line">    <span class="keyword">int</span> stackVariables = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> (^addBlock)(<span class="keyword">int</span> a, <span class="keyword">int</span> b) = ^ <span class="keyword">int</span> (<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        stackVariables++; <span class="comment">// 编译不通过</span></span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> add = addBlock(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.copy: 在定义完 Block 后 修改了 stackVariables 的值, 但是 Block 并不受影响</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)foo &#123;</span><br><span class="line">    <span class="keyword">int</span> stackVariables = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> (^addBlock)(<span class="keyword">int</span> a, <span class="keyword">int</span> b) = ^ <span class="keyword">int</span> (<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"stack variable = %ld"</span>, (<span class="keyword">long</span>)stackVariables);</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改 stackVariables 的值</span></span><br><span class="line">    stackVariables = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> add = addBlock(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要在 Block 中修改局部变量的值, 我们可以使用 __block 关键字来修饰变量,这样就可以在 Block 中修改变量了.对于用 __block 修饰的局部变量，Block 为其生成了一个 Struct 来存储引用地址.具体细节可以看唐巧大神写的<a href="http://blog.devtang.com/blog/2013/07/28/a-look-inside-blocks/" target="_blank" rel="external">谈Objective-C Block的实现</a></p>
<h3 id="retain_cycle"><a href="#retain_cycle" class="headerlink" title="retain cycle"></a>retain cycle</h3><p>Block 使用时,不仔细思量,就很容易出现循环引用,导致内存泄露.那到底什么时候会发生循环引用呢?<br>我们来修改一下刚刚的 Block 将他定义成 当前类的一个属性,同时在 Block 定义时,打印当前类的一个属性</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (^AddBlock)(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AddBlock addBlock;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSString</span> *memberVariable;</span><br><span class="line">...</span><br><span class="line">- (<span class="keyword">void</span>)foo &#123;</span><br><span class="line">    <span class="keyword">int</span> stackVariables = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">  	 _addBlock = ^ <span class="keyword">int</span> (<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">      	<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, _memberVariable);</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改 stackVariables 的值</span></span><br><span class="line">    stackVariables = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> add = addBlock(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 foo 中定义了一个 栈 Block 然后把它复制到 _addBlock 中去, 由于是从栈 copy 到堆,(这里要说一下: 在开启了 ARC 的情况下,因为编译器自动帮我们 copy 了,所以我们写 Block 的属性词时,用 copy 和 strong 都是一样的, 但是还是推荐使用 copy 啦,可以提醒我们编译器替我们做了 copy 操作😊)  Block 会持有 Block 中的变量.在 ARC 下, Block 中如果引用了 __strong 修饰符的自动变量,则相当于 Block 对该变量的引用计数+1. 由于 self 是 __strong 修饰.因此 self 持有了 Block, 同时 Block 也持有了 self.当 self 释放的时候,需要 Block 释放后才会对 self 进行释放,但是 Block 的释放又需要等 self 的 dealloc 方法中才会释放.如此一来变形成了循环引用，导致内存泄露.</p>
<p>你可能要问了,我这里并没有出现 self ?为什么 self 会被 Block 持有?</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其实 <span class="constant">_memberVariable </span>等价于 <span class="keyword">self</span>-&gt;memberVariable</span><br></pre></td></tr></table></figure>
<p>为了打破循环,我们需要取消引用可以将 self 用 __weak 所修饰</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (^AddBlock)(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AddBlock addBlock;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSString</span> *memberVariable;</span><br><span class="line">...</span><br><span class="line">- (<span class="keyword">void</span>)foo &#123;</span><br><span class="line">    <span class="keyword">int</span> stackVariables = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	 __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">  	 _addBlock = ^ <span class="keyword">int</span> (<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">      	<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, weakSelf<span class="variable">.memberVariable</span>);</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改 stackVariables 的值</span></span><br><span class="line">    stackVariables = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> add = addBlock(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__weak 变量有一个特性就是它不会影响所指向对象的生命周期,因此可以使用它来生成一个对自身对象的弱引用. 应该没有人的项目现在还不支持 ARC, 如果有, 那可以使用 __block 来打破循环. 那么__block typeof(self) weakSelf = self 就表示 Block 别再对 self 对象 retain 啦,这就打破了循环引用.</p>
]]></content:encoded>
      <comments>http://broccolii.github.io/2014/07/28/Objective-C_Block/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[用 GitHub & Hexo 在 Mac 上搭建博客]]></title>
      <link>http://broccolii.github.io/2014/07/08/GitHub_Hexo-Blog/</link>
      <guid>http://broccolii.github.io/2014/07/08/GitHub_Hexo-Blog/</guid>
      <pubDate>Tue, 08 Jul 2014 15:22:12 GMT</pubDate>
      <description>
      <![CDATA[<p>想搭建一个个人博客来记录一下自己学习的点滴,开发中遇到的问题,分享一下小经验.这篇文章作为 blog 的第一篇,分享一下如何基于 <a href="https://github.com" target="_blank" rel="external">GitHub</a> 和]]>
      </description>
      <content:encoded><![CDATA[<p>想搭建一个个人博客来记录一下自己学习的点滴,开发中遇到的问题,分享一下小经验.这篇文章作为 blog 的第一篇,分享一下如何基于 <a href="https://github.com" target="_blank" rel="external">GitHub</a> 和 <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a> 在 Mac 下搭建属于自己的博客.</p>
<h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><p>在搭建之前你需要一个 <a href="https://github.com" target="_blank" rel="external">GitHub</a> 账号,因为 blog 的文件都是托管在 GitHub 上的.你需要创建一个仓库 <code>+ New repository</code>,名称为 <code>GitHub用户名.github.io</code></p>
<h3 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h3><p>接下来我们会多次使用到 <a href="http://brew.sh" target="_blank" rel="external">homebrew</a></p>
<p>安装 <code>Homebrew</code> 直接使用 Mac 自带的 <code>ruby</code> 脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby <span class="operator">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>我们需要安装 <code>Git</code> 用来提交本地文件到 GitHub 的仓库中</p>
<p>推荐使用 <a href="http://brew.sh" target="_blank" rel="external">homebrew</a> 来安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install git</span><br></pre></td></tr></table></figure>
<h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>因为 <code>Hexo</code> 是基于 <code>Node.js</code> 的，所以必须安装 <code>Node.js</code> </p>
<p>继续推荐使用 <a href="http://brew.sh" target="_blank" rel="external">homebrew</a> 来安装</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install <span class="keyword">node</span><span class="identifier"></span><span class="title"></span></span><br></pre></td></tr></table></figure>
<p>如果你因为各种原因安装失败,又找不到解决办法.可以试一下直接下载安装包.<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a>官网下载 <code>.pkg</code> 安装包,双击安装.</p>
<p>使用以下命令输出版本号来验证是否安装成功:</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">node</span><span class="identifier"> </span><span class="title">-v</span></span><br><span class="line">$ npm -v</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><h4 id="Hexo__u5B89_u88C5"><a href="#Hexo__u5B89_u88C5" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h4><p><code>Hexo</code> 是基于 <code>Node.js</code> 实现的一款快速、简洁且高效的博客框架.</p>
<p>直接使用 <code>Node.js</code> 自带的包管理工具 <code>npm</code> 进行安装</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> hexo-cli</span></span><br></pre></td></tr></table></figure>
<p>如果因为权限问题可以使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> hexo-cli</span></span><br></pre></td></tr></table></figure>
<h4 id="Hexo__u8BBE_u7F6E"><a href="#Hexo__u8BBE_u7F6E" class="headerlink" title="Hexo 设置"></a>Hexo 设置</h4><p>以下操作需要在你希望 blog 生成的路径下进行<br>1.新建博客目录 </p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo init <span class="variable">$&#123;</span>blog 的本地目录名&#125;</span><br></pre></td></tr></table></figure>
<p>2.根据当前目录下的文件生成静态网页</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo generate</span><br></pre></td></tr></table></figure>
<p>3.初始化依赖</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span></span><br></pre></td></tr></table></figure>
<p>4.启动服务</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="keyword">server</span></span><br></pre></td></tr></table></figure>
<p>操作到这里时,可以在浏览器中 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 看到生成的好的 blog</p>
<h4 id="u6258_u7BA1_u5230_GitHub__u4E0A"><a href="#u6258_u7BA1_u5230_GitHub__u4E0A" class="headerlink" title="托管到 GitHub 上"></a>托管到 GitHub 上</h4><p>打开 <code>_config.yml</code>, 配置 <code>GitHub</code> 信息 PS: yml 是有严格的格式要求,所以一定要两个空格哦~</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="comment">#部署类型, 本文使用Github</span></span><br><span class="line">  <span class="operator">type</span>: git    		</span><br><span class="line">  <span class="comment">#部署的仓库的链接         </span></span><br><span class="line">  repository: <span class="tag">&lt;GitHub用户名.github.io 这个仓库所在的路径&gt;</span>.git</span><br><span class="line">  <span class="comment">#部署分支,一般使用master主分支      </span></span><br><span class="line">  branch: <span class="literal">master</span></span><br></pre></td></tr></table></figure>
<p>使用命令:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo deploy</span><br></pre></td></tr></table></figure>
<p>在执行 hexo deploy 后,出现 error deployer not found:git 的错误处理</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="operator"><span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span></span><br></pre></td></tr></table></figure>
<p>将网页发布到 GitHub 上,然后可以在 <a href="http://GitHub用户名.github.io" target="_blank" rel="external">http://GitHub用户名.github.io</a> 看到发布成功的 Blog</p>
]]></content:encoded>
      <comments>http://broccolii.github.io/2014/07/08/GitHub_Hexo-Blog/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
