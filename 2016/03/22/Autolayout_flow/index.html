<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="不求深刻,但求简单."><title>Auto Layout 绘制流程 | 一朵西兰花</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/rss+xml" href="/rss2.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Auto Layout 绘制流程</h1><a id="logo" href="/.">一朵西兰花</a><p class="description">不求深刻,但求简单.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Auto Layout 绘制流程</h1><div class="post-meta">Mar 22, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2016/03/22/Autolayout_flow/" href="/2016/03/22/Autolayout_flow/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>和朋友讨论 <code>layout</code> 和 <code>constraint</code> 之间的关系, 发现自己并不是很理解 <code>constraint</code> 绘制页面的顺序. </p>
<h3 id="Auto_Layout__u7ED8_u5236_u6D41_u7A0B"><a href="#Auto_Layout__u7ED8_u5236_u6D41_u7A0B" class="headerlink" title="Auto Layout 绘制流程"></a>Auto Layout 绘制流程</h3><p>Auto Layout 显示一个 view 时, 会经过 <code>update constraints -&gt; layout views -&gt; display</code> 这三步. 详情请点<a href="http://stackoverflow.com/questions/20609206/setneedslayout-vs-setneedsupdateconstraints-and-layoutifneeded-vs-updateconstra" target="_blank" rel="external">Stackoverflow</a> </p>
<blockquote>
<p>引用自:<a href="http://objccn.io/issue-3-5/" target="_blank" rel="external">objc.io 先进的自动布局工具箱</a><br>第一步：update constraints,可以被认为是一个“计量传递 (measurement pass)”.这是自下而上（从子视图到父视图）发生的,它为布局准备好必要的信息,而这些布局将在实际设置视图的 frame 时被传递过去并被使用.你可以通过调用 <code>setNeedsUpdateConstraints</code> 来触发这个操作.同时,你对约束条件系统做出的任何改变都将自动触发这个方法.无论如何,通知自动布局关于自定义视图中任何可能影响布局的改变是非常有用的.谈到自定义视图,你可以在这个阶段重写 <code>updateConstraints</code> 来为你的视图增加需要的本地约束.</p>
<p>第二步：layout views,这是个自上而下（从父视图到子视图）的过程,这种布局操作实际上是通过设置 frame（在 OS X 中）或者 center 和 bounds（在 iOS 中）将约束条件系统的解决方案应用到视图上.你可以通过调用 setNeedsLayout 来触发一个操作请求,这并不会立刻应用布局,而是在稍后再进行处理.因为所有的布局请求将会被合并到一个布局操作中去,所以你不需要为经常调用这个方法而担心.</p>
<p>第三步：display,将 view 渲染到屏幕上,它与是否使用 Auto Layout 无关,其操作是从上向下(从父视图到子视图),通过调用 <code>setNeedsDisplay</code> 触发.</p>
</blockquote>
<p>如下图所示:</p>
<div style="text-align: center"><br><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/Autolayout_flow/constraint_layoutSubview_display.png"><br></div>

<p>在图中我们看见,<code>layout views</code> 会触发 <code>updating constraints</code>, 从而触发新的一轮绘制. 原因是: 当 <code>layoutSubviews</code> 被调用时, 会触发 <code>updateConstraintsIfNeeded</code>, 如果进行了 <code>constraint</code> 修改的操作, 那么会调用 <code>updating constraints</code>. 这也就解释了为什么 <code>UIView</code> 动画中,修改了 <code>constraint</code> 需要调用 <code>layoutIfNeeded</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改了约束</span></span><br><span class="line">UIView.animateWithDuration(<span class="number">1.0</span>) &#123;</span><br><span class="line">    aniamtionView.layoutIfNeeded()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><p>系统提供了几个关于 <code>constraint</code> 的方法 分别是</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setNeedsUpdateConstraints</span><span class="params">()</span> &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>当一个 view 的某个属性发生改变,并且可能影响到 <code>constraint</code> 时, 则标记被修改的 <code>constraint</code>. 此方法标记的 <code>constraints</code> 会在未来的某个时间点更新，系统然后调用 <code>updateConstraints</code>.</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needsUpdateConstraints</span><span class="params">()</span> -&gt; <span class="title">Bool</span> &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>系统通过这个方法的返回值判断 <code>constraint</code> 是否需要更新.</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateConstraintsIfNeeded</span><span class="params">()</span> &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>立即更新被标记 <code>setNeedsUpdateConstraints</code> 的 <code>constraint</code></p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateConstraints</span><span class="params">()</span> &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>自定义 view 时,我们可以重写这个方法做约束修改进行相应的操作. 但必须在 <code>viewDidLoad</code> 之后, <code>viewWillLayoutSubviews</code> 之前调用 <strong>注意: 重写这个方法时,一定要调用 super.updateConstraints()</strong><br><strong>总结:</strong><br>标记 view 的 <code>setNeedsUpdateConstraints</code>, 在未来的某个时刻系统调用 <code>needsUpdateConstraints</code> 根据返回值, 会触发 <code>updateConstraints</code>, 然后更新约束. 使用 <code>updateConstraintsIfNeeded</code> 则是立即更新所有被标记的 <code>constraint</code>.</p>
<h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><p>关于 <code>Layout</code> 也有类似 <code>constraint</code> 的几个方法</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setNeedsLayout</span><span class="params">()</span> &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">layoutIfNeeded</span><span class="params">()</span> &#123;&#125; </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span> &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>系统会在 <code>RunLoop</code> 周期中的某个时刻自动调用 <code>layoutSubviews</code>.开发者不需要手动调用 <code>layoutSubviews</code>, 只需要重写该方法. <strong>此时并不会发生屏幕绘制.</strong></p>
<blockquote>
<p>The default implementation of this method does nothing on iOS 5.1 and earlier. Otherwise, the default implementation uses any constraints you have set to determine the size and position of any subviews.</p>
<p>Subclasses can override this method as needed to perform more precise layout of their subviews.<strong> You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want.</strong> You can use your implementation to set the frame rectangles of your subviews directly.</p>
<p>You should not call this method directly. If you want to force a layout update, call the setNeedsLayout method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.</p>
</blockquote>
<p>官方文档中说明,不要直接调用此方法.如果你想强制更新布局,先调用 <code>setNeedsLayout</code> 方法接着立即调用 <code>layoutIfNeeded</code>.</p>
<p>以下几种情况系统会调用<code>layoutSubviews</code>:</p>
<ul>
<li><code>addSubview</code> 会触发 <code>layoutSubviews</code></li>
<li>修改了 view 的 frame 会触发自身以及父视图的 <code>layoutSubviews</code>.</li>
<li>滚动一个 UIScrollView 会触发 <code>layoutSubviews</code></li>
<li>旋转 Screen 会触发当前 view 的 <code>layoutSubviews</code></li>
</ul>
<h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><p>关于 <code>display</code> 就只有两个方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func drawRect(rect: CGRect) &#123;&#125;&#10;func setNeedsDisplay() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>之所以没有 <code>ifNeeded</code> 方法是因为 <code>display</code> 的绘制周期是 1/60 秒. 关于 <code>drawRect</code> 的一些内容可以看一下 <a href="http://bihongbo.com/2016/01/03/memoryGhostdrawRect/" target="_blank" rel="external">内存恶鬼drawRect</a></p>
<h3 id="frame__u548C_bounds"><a href="#frame__u548C_bounds" class="headerlink" title="frame 和 bounds"></a>frame 和 bounds</h3><p>在 display 到页面上后,有两个容易不清的属性: <code>frame</code> 和 <code>bounds</code>. 先看一下两者关系的一张图:<br><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/iOS_UIView_CALayer/CAlayer_frame.jpg" alt=""></p>
<ol>
<li>UIView 的 center 直接调用 rootLayer 的 position </li>
<li>UIView 的 bounds 直接调用 rootLayer 的 bounds</li>
<li>UIView 的 frame 直接调用 rootLayer 的 frame</li>
<li>rootLayer 的 frame 又是 <code>anchorPoint</code>, <code>position</code>, <code>bounds</code>, <code>transform</code> 四个属性的派生属性<br>既然九九归一,最后都是这四个属性在影响着 frame 的大小.我们先从 <code>anchorPoint</code> 和 <code>position</code> 着手,因为 <code>position</code> 是 <code>anchorPoint</code> 在 superLayer 上的投影坐标.<br><strong>anchorPoint</strong><br><code>anchorPoint</code> (锚点) 顾名思义是一个固定点,在做 transform 时,会以 <code>anchorPoint</code> 作为固定点旋转.在 iOS 中,anchorPoint 的值是以相对 bounds 的比例值来确定的.默认是(0.5，0.5),如果觉得太抽象可以看下图:</li>
</ol>
<p><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/iOS_UIView_CALayer/layer_coords_anchorpoint_position_2x-2.png" alt=""><br><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/iOS_UIView_CALayer/anchorpoint2.jpg" alt=""></p>
<p><strong>position</strong><br><code>position</code> 的定义是 <code>The position in the superlayer that the anchor point of the layer&#39;s bounds rect is aligned t</code> position 是 layer 相对 superLayer 坐标空间的位置.我们可以想象一下,我们是一条很大很大的邮轮停在大西洋上,我们向陆地发送的坐标就是船锚的位置.船锚的位置只能是相对于船身来说的,类比 <code>anchorPoint 的值是以相对 bounds 的比例值来确定的</code>.是不是很好理解呢(捂脸逃<br>PS: 这有一篇更好的文章 <a href="http://wonderffee.github.io/blog/2013/10/13/understand-anchorpoint-and-position/" target="_blank" rel="external">彻底理解position与anchorPoint</a></p>
<p><strong>bounds</strong><br>bounds 分为两部分: origin 和 size.bounds.size 定义了图层的大小,bounds.origin 却并不表示图层的位置,而是定了内部坐标系的原点.那什么是内部坐标系的原点呢?指的是图层内部子图层的坐标系,就是说如果修改了 bounds.origin 的自身不会发生任何变化,但是在其内部的子图层会发生位移.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *lightGrayView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">lightGrayView<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:lightGrayView];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">UIView</span> *orangeView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">25</span>, <span class="number">25</span>, <span class="number">50</span>, <span class="number">50</span>)];</span><br><span class="line">orangeView<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line">[lightGrayView addSubview:orangeView];</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/iOS_UIView_CALayer/bounds_demo1.png" alt=""><br>修改 bounds 追加以下代码<br><code>lightGrayView.layer.bounds = CGRectMake(20, 20, 100, 100);</code><br><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/iOS_UIView_CALayer/bounds_demo2.png" alt=""></p>
<p><strong>transform</strong><br>为什么 <code>transform</code> 会影响 frame 呢? 让我们来动手试一下吧</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *redView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>)];</span><br><span class="line">redView<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:redView];</span><br><span class="line">redView<span class="variable">.transform</span> = <span class="built_in">CGAffineTransformMakeRotation</span>(M_PI_4);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"redView.frame : --- %@"</span>, <span class="built_in">NSStringFromCGRect</span>(redView<span class="variable">.frame</span>));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"redView.bounds : --- %@"</span>, <span class="built_in">NSStringFromCGRect</span>(redView<span class="variable">.bounds</span>));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"redView.layer.frame : --- %@"</span>, <span class="built_in">NSStringFromCGRect</span>(redView<span class="variable">.layer</span><span class="variable">.frame</span>));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"redView.layer.bounds : --- %@"</span>, <span class="built_in">NSStringFromCGRect</span>(redView<span class="variable">.layer</span><span class="variable">.frame</span>));</span><br></pre></td></tr></table></figure>
<p>输出如下:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redView.frame : --- <span class="expansion">&#123;&#123;<span class="number">79.289321881345259</span>, <span class="number">79.289321881345245</span>&#125;, &#123;<span class="number">141.42135623730951</span>, <span class="number">141.42135623730951</span>&#125;&#125;</span></span><br><span class="line">redView.bounds : --- <span class="expansion">&#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">100</span>, <span class="number">100</span>&#125;&#125;</span></span><br><span class="line">redView.layer.frame : --- <span class="expansion">&#123;&#123;<span class="number">79.289321881345259</span>, <span class="number">79.289321881345245</span>&#125;, &#123;<span class="number">141.42135623730951</span>, <span class="number">141.42135623730951</span>&#125;&#125;</span></span><br><span class="line">redView.layer.bounds : --- <span class="expansion">&#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">100</span>, <span class="number">100</span>&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>frame 的大小是一个包含了经过转换后的顶点的最小矩形,如下图灰框所示:<br><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/iOS_UIView_CALayer/transform_demo.png" alt=""></p>
<p>那么 frame 和这四个属性之间到底是什么关系呢? 在不考虑 transform 的情况下是(三角函数实在是太难了啊!摔:</p>
<blockquote>
<p>frame.origin.x = position.x - anchorPoint.x * bounds.size.width<br>frame.origin.y = position.y - anchorPoint.y * bounds.size.height<br>frame.size.width = bounds.size.width<br>frame.size.height = bounds.size.height</p>
</blockquote>
<h3 id="u5706_u89D2__u4E0E__u79BB_u5C4F_u6E32_u67D3"><a href="#u5706_u89D2__u4E0E__u79BB_u5C4F_u6E32_u67D3" class="headerlink" title="圆角 与 离屏渲染"></a>圆角 与 离屏渲染</h3><p>Nic 提到既然写到了 <code>display</code> 顺便写一下圆角绘制吧。最近好多文章说到高性能绘制圆角，无外乎以下三种方式：</p>
<ol>
<li>CAShapeLayer 搭配 UIBezierPath 做一个 mask view</li>
<li>使用 Core Graphics 裁掉 UIImage 四个角</li>
<li>使用 layer 的 cornerRadius 属性，根据是否有子视图添加 <code>masksToBounds</code></li>
</ol>
<p>还有一些直接使用圆角图片的方法这里就不做一一列举了。<br>这里需要说明的是: 光设置 <code>cornerRadius</code> 并不会触发离屏渲染，只有使用了 <code>maskToBounds</code> 才会触发。同理方法一也被否决了，因为 CAShapeLayer 的实现原理是 <code>mask view</code> 并不能提高性能。同时设置 <code>mask view</code> 的方法需要在 <code>- (void)drawRect:(CGRect)rect;</code> 中调用，这会增加内存消耗。<a href="http://bihongbo.com/2016/01/03/memoryGhostdrawRect/" target="_blank" rel="external">原理详见 内存恶鬼drawRect</a>。Core Graphics 是使用了 CPU 来做处理，所以不需要担心会触发离屏渲染。</p>
<p>离屏渲染的概念来自于 OpenGL 中 GPU 渲染屏幕的两种方式： <code>On-Screen Rendering（当前屏幕渲染）</code> 和 <code>Off-Screen Rendering（离屏渲染）</code>。 指的是：在当前屏幕以外新开辟一个缓冲区进行渲染操作。离屏渲染造成卡顿的原因是：离屏渲染需要多次切换上下文环境，先是从当前屏幕(On-Screen)切换到离屏(Off-Screen)，等到离屏渲染结束以后,将离屏缓冲区的渲染结果显示到屏幕上又需要将上下文环境从离屏切换到当前屏幕,而上下文环境的切换是一项高开销的动作。 CALayer 的 border、圆角、阴影、遮罩(mask)，CAShapeLayer 的矢量图形显示，通常会触发离屏渲染，我们在实际开发中都需要注意。<br>既然说到了离屏渲染不得不提的就是 <code>光栅化</code>，开启 <code>shouldRasterize</code> 属性就会触发离屏渲染。常常有文章会提到使用 <code>shouldRasterize</code> 来优化 UI 页面，其实需要具体情况具体分析。<code>光栅化</code> 其实就是将图转化为一个个栅格组成的图象缓存起来会，如果对应的 layer 及其 sublayers 没有发生改变，在下一帧的时候可以直接复用。这将 GPU 的工作，转嫁到了 CPU 上。写入缓存再读取有可能消耗较多的时间，因次 <code>光栅化</code> 不适用于重绘很频繁的页面。<a href="https://developer.apple.com/videos/play/wwdc2012/238/" target="_blank" rel="external">WWDC 有说明</a></p>
<p><strong>Q&amp;A</strong><br>问: 使用 Auto Layout 之后什么时候才能获得正确的 frame?<br>答: <code>viewDidLayoutSubviews</code> 之后</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://broccolii.github.io/2016/03/22/Autolayout_flow/" data-id="cimydtcsj0017j620q2vci7po" class="article-share-link">分享到</a><div class="tags"><a href="/tags/UITableView/">UITableView</a></div><div class="post-nav"><a href="/2016/04/03/Objective-C_initialize_load/" class="pre">Objective-C 中的 load 和 initialize</a><a href="/2016/03/16/iOS_database/" class="next">Core Data, FMDB, Realm 性能对比</a></div><div id="disqus_thread"><script>var disqus_shortname = 'broccoliii';
var disqus_identifier = '2016/03/22/Autolayout_flow/';
var disqus_title = 'Auto Layout 绘制流程';
var disqus_url = 'http://broccolii.github.io/2016/03/22/Autolayout_flow/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//broccoliii.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><input placeholder="Search" type="text" class="st-default-search-input"/></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/UITableView/" style="font-size: 15px;">UITableView</a> <a href="/tags/Thread/" style="font-size: 15px;">Thread</a> <a href="/tags/Database/" style="font-size: 15px;">Database</a> <a href="/tags/RunLoop/" style="font-size: 15px;">RunLoop</a> <a href="/tags/CoreSpotlight/" style="font-size: 15px;">CoreSpotlight</a> <a href="/tags/3DTouch/" style="font-size: 15px;">3DTouch</a> <a href="/tags/Chrome/" style="font-size: 15px;">Chrome</a> <a href="/tags/Debug/" style="font-size: 15px;">Debug</a> <a href="/tags/ReactiveCocoa/" style="font-size: 15px;">ReactiveCocoa</a> <a href="/tags/Objective-C/" style="font-size: 15px;">Objective-C</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/Block/" style="font-size: 15px;">Block</a> <a href="/tags/CocoaPods/" style="font-size: 15px;">CocoaPods</a> <a href="/tags/Alfred/" style="font-size: 15px;">Alfred</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/04/12/iOS_debug/">iOS 开发中的调试小技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/03/Objective-C_initialize_load/">Objective-C 中的 load 和 initialize</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/22/Autolayout_flow/">Auto Layout 绘制流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/16/iOS_database/">Core Data, FMDB, Realm 性能对比</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/02/Alfred_3_config/">Alfred 2 配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/04/CocoaPods_private_library/">使用 CocoaPods 管理私有库</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/26/UITableView_Optimization/">UITableView 性能优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/31/ReactiveCocoa_exploration/">ReactiveCocoa 整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/06/iOS9_3D_Touch/">iOS9 中的 3D Touch</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/10/02/iOS9_CoreSpotlight/">iOS9 中的 CoreSpotlight</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//broccoliii.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">一朵西兰花.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

_st('install','UKkneeeyb79HvjysWVot','2.0.0');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?64b81a3596d6c5ec76f245076ec9bd2a";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>