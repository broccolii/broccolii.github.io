<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[一朵西兰花]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://broccolii.github.io/"/>
  <updated>2016-01-15T10:44:08.000Z</updated>
  <id>http://broccolii.github.io/</id>
  
  <author>
    <name><![CDATA[Broccoliii]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[ReactiveCocoa 整理]]></title>
    <link href="http://broccolii.github.io/2015/12/31/ReactiveCocoa_exploration/"/>
    <id>http://broccolii.github.io/2015/12/31/ReactiveCocoa_exploration/</id>
    <published>2015-12-30T19:52:39.000Z</published>
    <updated>2016-01-15T10:44:08.000Z</updated>
    <content type="html"><![CDATA[<h3 id="ReactiveCocoa__u662F_u4EC0_u4E48"><a href="#ReactiveCocoa__u662F_u4EC0_u4E48" class="headerlink" title="ReactiveCocoa 是什么"></a>ReactiveCocoa 是什么</h3><p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a>（简称为RAC）,是由 Github 开源的一个应用于iOS和OS开发的新框架.是一个 iOS 中的函数式响应式编程框架.(注: 文本例子使用 ReactiveCocoa 2.5)</p>
<h3 id="ReactiveCocoa__u7684_u4F5C_u7528"><a href="#ReactiveCocoa__u7684_u4F5C_u7528" class="headerlink" title="ReactiveCocoa 的作用"></a>ReactiveCocoa 的作用</h3><p>在 iOS 开发过程中,我们需要监听不同的事件,并作出反应,例如对 <code>UIButton</code> 的点击事件使用 <code>TA</code> 模式,对 <code>UIScrollView</code> 的滚动事件使用 <code>delegate</code>,对属性变化监听使用 <code>KVO</code>.那么我们可能会想能不能使用同一的标准? <code>ReactiveCocoa</code> 为我们提供了一个单独的、统一的方法来这些行为.它可以把要处理的事情,和监听的事情的代码放在一起,便于我们管理代码,非常符合我们开发中<code>高聚合,低耦合</code>的思想.</p>
<h3 id="u7F16_u7A0B_u8303_u5F0F_3A__u51FD_u6570_u5F0F_u7F16_u7A0B_/__u54CD_u5E94_u5F0F_u7F16_u7A0B"><a href="#u7F16_u7A0B_u8303_u5F0F_3A__u51FD_u6570_u5F0F_u7F16_u7A0B_/__u54CD_u5E94_u5F0F_u7F16_u7A0B" class="headerlink" title="编程范式: 函数式编程 / 响应式编程"></a>编程范式: 函数式编程 / 响应式编程</h3><p><em>ReactiveCocoa被描述为函数响应式编程（FRP）框架,使用 FRP 有两个好处: 直观和灵活.</em><br><strong>函数式编程(Functional Programming)</strong><br>函数式编程(functional programming)简单的来说就是一种编程范型,主要思想是把运算过程尽量写成一系列嵌套的函数调用.函数编程语言最重要的基础是 λ 演算(lambda calculus),而且 λ 演算的函数可以接受函数当作输入和输出.函数式编程更加强调程序执行的结果而非执行的过程,倡导利用若干简单的执行单元让计算结果不断渐进,逐层推导复杂的运算,而不是设计一个复杂的执行过程.<br>阮一峰老师有一个关于<a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank" rel="external">函数式编程</a>的例子,如下:</p>
<blockquote>
<p>举例来说,现在有这样一个数学表达式：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span> + <span class="number">2</span>) * <span class="number">3</span> - <span class="number">4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们可能会这样写:</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> a</span> = <span class="number">1</span> + <span class="number">2</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> b</span> = a * <span class="number">3</span>　　</span><br><span class="line"><span class="variable"><span class="keyword">var</span> c</span> = b - <span class="number">4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数式编程要求使用函数,我们可以把运算过程定义为不同的函数,然后写成下面这样：</p>
</blockquote>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">result</span> = subtract(multiply(add(<span class="number">1</span>,<span class="number">2</span>), <span class="number">3</span>), <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这就是函数式编程</p>
</blockquote>
<p><strong>响应式编程(Reactive Programming).</strong><br>响应式编程是一种面向数据流和变化传播的编程范式.这意味着可以在编程语言中很方便地表达静态或动态的数据流,而相关的计算模型会自动将变化的值通过数据流进行传播.我们看一下刚刚阮老师的代码 <code>var b = a * 3</code> 如果 <code>a</code> 的值从 3 变成了 5, 那么 <code>b</code> 的值会随着 <code>a</code> 的变化而变化. <code>b</code> 的值就从 9 变为了 15.</p>
<h3 id="ReactiveCocoa__u57FA_u672C_u6982_u5FF5"><a href="#ReactiveCocoa__u57FA_u672C_u6982_u5FF5" class="headerlink" title="ReactiveCocoa 基本概念"></a>ReactiveCocoa 基本概念</h3><p><strong>RACSignal</strong><br>ReactiveCocoa 的核心就是 RACSignal,也就是信号,我们可以直接创建信号 <code>createSignal</code>,并发送 <code>sendNext</code> 进行下一步操作,当信号完成后我们可以调用 <code>sendCompleted</code>,我们同时用 <code>dispose</code> 方法销毁它 .当然如果信号因为发生错误而终止,也可以发送错误信号 <code>sendError</code>.当我们使用了 <code>sendCompleted</code> 和 <code>sendError</code> 就不能继续发送 <code>sendNext</code>,因为信号已经终止结束.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建信号</span></span><br><span class="line">RACSignal *signal = [RACSignal <span class="string">createSignal:</span>^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">	<span class="comment">// 发送信号</span></span><br><span class="line">   [subscriber <span class="string">sendNext:</span>@<span class="string">"下一步"</span>];</span><br><span class="line">   [subscriber <span class="string">sendError:</span>[NSError <span class="keyword">new</span>]];</span><br><span class="line">   [subscriber sendCompleted];</span><br><span class="line">   <span class="comment">// 取消订阅</span></span><br><span class="line">   <span class="keyword">return</span> [RACDisposable <span class="string">disposableWithBlock:</span>^&#123;</span><br><span class="line">      <span class="comment">// 信号被销毁时调用</span></span><br><span class="line">   &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>如下图所示: 我们可以使用 RACSignal 可以来替代 iOS 中传统的 Delegate,Block,Target Action,KVO,Notification.</p>
<div style="text-align: center"><br><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/ReactiveCocoa_exploration/RACSignal.jpg"><br></div>

<p>创建了一个信号,需要有订阅者来接受它,否则它就是一个待激活的状态.可以使用 <code>subscribeNext:</code> 激活信号.此时有了订阅者,才会发生 <code>sendNext:</code>, <code>sendError:</code>, <code>sendCompleted</code>. 所以一个信号的正确流程应该是 1. 创建信号,2. 订阅信号, 3. 发送信号.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅信号</span></span><br><span class="line">[signal <span class="string">subscribeNext:</span>^(id x) &#123;</span><br><span class="line">   <span class="comment">// 接收 next 操作</span></span><br><span class="line">&#125; <span class="string">error:</span>^(NSError *error) &#123;</span><br><span class="line">   <span class="comment">// 接收 error 操作</span></span><br><span class="line">&#125; <span class="string">completed:</span>^&#123;</span><br><span class="line">   <span class="comment">// 接收 complete 操作</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><strong>RACSubscriber</strong><br>我们现在对信号的产生和发送有了一些了解, 在 ReactiveCocoa 中,其实并不存在一个订阅者的实例,凡是实现 <code>RACSubscriber</code> 协议的类都可以作为订阅者.<br>协议里有四个方法</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@protocol</span> RACSubscriber &lt;NSObject&gt;</span><br><span class="line"><span class="annotation">@required</span></span><br><span class="line"></span><br><span class="line">- (<span class="typename">void</span>)<span class="string">sendNext:</span>(id)value;</span><br><span class="line">- (<span class="typename">void</span>)<span class="string">sendError:</span>(NSError *)error;</span><br><span class="line">- (<span class="typename">void</span>)sendCompleted;</span><br><span class="line">- (<span class="typename">void</span>)<span class="string">didSubscribeWithDisposable:</span>(RACCompoundDisposable *)disposable;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>-sendNext:</code>,<code>-sendError:</code> 和 <code>-sendCompleted</code>,刚刚我们用于发送了不同类型的信号, 而 <code>didSubscribeWithDisposable:</code> 用于接收代表某次订阅的 disposable 对象,告诉订阅者你订阅了哪些信号.我们也可以用返回的 <code>RACDisposable</code> 手动取消订阅者</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RACDisposable *disposable = [signal <span class="string">subscribeNext:</span>^(id x) &#123;</span><br><span class="line">   <span class="comment">// 接收 next 操作</span></span><br><span class="line">&#125; <span class="string">error:</span>^(NSError *error) &#123;</span><br><span class="line">   <span class="comment">// 接收 error 操作</span></span><br><span class="line">&#125; <span class="string">completed:</span>^&#123;</span><br><span class="line">   <span class="comment">// 接收 complete 操作</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 手动取消订阅者    </span></span><br><span class="line">[disposable dispose];</span><br></pre></td></tr></table></figure>
<p>RACSignal 默认替我们实现了 <code>RACSubscriber</code> 协议,点进 RACSignal 的源码可以在 <code>@implementation RACSignal (Subscription)</code> 看到,实现订阅者的方法.这里有一个与 <code>RACSubscriber</code> 协议同名的 <code>RACSubscriber</code>类.这与 <code>NSObject</code> 协议与 <code>NSObject</code>类同名类似. <code>RACSubscriber</code> 类就是真正的订阅者,不过在 ReactiveCocoa 中,倾向于隐藏订阅者,让程序员只关注信号就可以了.</p>
<p><strong>RACDisposable</strong><br>RACDisposable 用于取消订阅与资源清理(cancellation and resource cleanup).当信号发送完成或发送错误的时候,就会自动触发 <code>[disposable dispose];</code>.</p>
<p><strong>RACSubject</strong><br>RACSubject 是一个可以手动控制的信号,我们可以把它看作是 RACSignal 的可变版本.RACSubject 继承自 RACSignal ,所以它可以作为信号源被订阅者订阅,同时,它又实现了 RACSubscriber 协议,所以它也可以作为订阅者订阅其他信号源. RACSubject 可以看作是信号的一个可变体(variant),就像NSMutableArray之于NSArray.它对于桥接(bridging)非RAC代码到信号中去(into the world of signals)非常有用.RACSubject 的功能非常强大,但是太过灵活,也正是因为如此,我们只有在迫不得已的情况下才会使用它.</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="name">RACSubject</span> *<span class="atom">signal</span> = [<span class="name">RACSubject</span> <span class="atom">subject</span>];</span><br><span class="line">[<span class="atom">signal</span> <span class="atom">subscribeNext</span>:^(<span class="atom">id</span> <span class="atom">x</span>) &#123;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[<span class="atom">signal</span> <span class="atom">sendNext</span>:@<span class="string">"signal"</span>];</span><br></pre></td></tr></table></figure>
<p><strong>RACSequence</strong><br>RACSequence 类可以简单看做是 ReactiveCocoa 的 NSArray, ReactiveCocoa使用 <code>rac_sequence</code> 方法,可以使 Objective-C 中的集合类（collection classes）直接转换为RACSequence 来使用</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">NSArray</span> *numbers = <span class="annotation">@[<span class="variable">@1</span>,<span class="variable">@2</span>,<span class="variable">@3</span>,<span class="variable">@4</span>]</span>;</span><br><span class="line">[numbers.rac_sequence.signal <span class="symbol">subscribeNext:</span>^(id x) &#123;</span><br><span class="line"><span class="regexp">//</span> 遍历数组</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><strong>RACScheduler</strong><br>RACScheduler 在 ReactiveCocoa 中类似 GCD 的队列,是管理线程的一个类.负责 ReactiveCocoa 中让信号发出的事件在线程中穿梭,尤其是想更新 UI 必须在主线程中的时候,可以让事件直接从其他线程跳到主线程.本质上它是基于 GCD 的串行队列实现,并且支持取消操作.</p>
<p><strong>RACMulticastConnection</strong><br>RACMulticastConnection 是一个在任意数量订阅者之间共享的一个订阅者(subscription).<br>信号在默认情况下是冷的,每当添加一个新的订阅,信号的 block 就会被调用一次,如果 block 中实现的是网络请求,那么会发生多次请求.(这里与 replay 不同的是,replay 是会产生多次信号,不过只发送第一次的,而 RACMulticastConnection 只会产生一次)</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"网络请求"</span>);</span><br><span class="line">   [subscriber sendNext:<span class="string">@"signal"</span>];</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACMulticastConnection *connect = [signal publish];</span><br><span class="line"></span><br><span class="line">[connect<span class="variable">.signal</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[connect<span class="variable">.signal</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.连接,激活信号</span></span><br><span class="line">[connect connect];</span><br></pre></td></tr></table></figure>
<h3 id="ReactiveCocoa__u4E2D_u7684_u5E38_u7528_u5F02_u6B65_u5904_u7406"><a href="#ReactiveCocoa__u4E2D_u7684_u5E38_u7528_u5F02_u6B65_u5904_u7406" class="headerlink" title="ReactiveCocoa 中的常用异步处理"></a>ReactiveCocoa 中的常用异步处理</h3><ul>
<li>Delegate (有局限,只能取代没有返回值的代理方法)</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="keyword">self</span> rac_signalForSelector:<span class="keyword">@selector</span>(textFieldDidBeginEditing:)</span><br><span class="line"> fromProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">UITextFieldDelegate</span>)]</span></span><br><span class="line"> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="comment">// 代理方法</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<ul>
<li>Target-Action</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[button rac_signalForControlEvents:UIControlEventTouchUpInside]</span></span><br><span class="line"> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">// 点击事件  </span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>KVO</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[RACObserve<span class="list">(<span class="keyword">scrollView</span>, contentOffset)</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">// 监听 scrollView 的偏移量</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Notification</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[NSNotificationCenter defaultCenter]</span> rac_addObserverForName:UIApplicationDidEnterBackgroundNotification object:nil]</span> subscribeNext:^<span class="list">(<span class="keyword">NSNotification</span> * notification)</span> <span class="collection">&#123;</span><br><span class="line">// 收到通知 </span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定时器</li>
</ul>
<p>1.延迟一段时间后再做某件事</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[[RACScheduler mainThreadScheduler]</span> <span class="tag">afterDelay</span><span class="pseudo">:2</span> <span class="tag">schedule</span>:^&#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>2.每个一定长度时间做一件事</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[RACSignal interval:1 onScheduler:<span class="collection">[RACScheduler mainThreadScheduler]</span>]</span>subscribeNext:^<span class="list">(<span class="keyword">NSDate</span> * date)</span> <span class="collection">&#123;</span><br><span class="line">// do something</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>手势</li>
</ul>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UITapGestureRecognizer *tap = <span class="comment">[<span class="comment">[UITapGestureRecognizer alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[<span class="comment">[tap rac_gestureSignal]</span> subscribeNext:^(UITapGestureRecognizer * tap) &#123;</span><br><span class="line">// 手势操作</span><br><span class="line">&#125;]</span>;</span><br><span class="line"><span class="comment">[self.view addGestureRecognizer:tap]</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>文本框文字改变 </li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[textField rac_textSignal]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="u5B8F_u5B9A_u4E49"><a href="#u5B8F_u5B9A_u4E49" class="headerlink" title="宏定义"></a>宏定义</h3><p><strong>RAC()</strong> 可以将 RACSignal 发出事件的值赋给某个对象的某个属性</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(self.labelView,<span class="keyword">text</span>) = <span class="keyword">textField</span>.rac_textSignal;</span><br></pre></td></tr></table></figure>
<p><strong>RACObserve()</strong> 新建一个 <code>RACSignal</code> 并对对象的属性的值进行观察</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[RACObserve<span class="list">(<span class="keyword">textField</span>, text)</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">// 当 text 发生改变时,会接收到信号</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>RACTuplePack</strong> 把数据包装成 RACTuple 类型</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACTuple *tuple = RACTuplePack(<span class="constant">@10</span>,<span class="constant">@20</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>RACTupleUnpack</strong> 把 RACTuple 类型解包</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// num1 = 10, num2 = 20</span></span><br><span class="line">RACTupleUnpack(<span class="built_in">NSNumber</span> *num1,<span class="built_in">NSNumber</span> *num2) = tuple;</span><br></pre></td></tr></table></figure>
<p><strong>@weakify(Obj) / @strongify(Obj)</strong><br>用来生成 <code>__weak的self_weak_变量</code> 和 <code>__strong的self指针指向self_weak</code> 用来处理 block 调用中的 循环引用.实现细节可以参考 <a href="http://blog.sunnyxx.com/2014/03/06/rac_1_macros/" target="_blank" rel="external">sunnyxx 大神的 神奇的Macros</a></p>
<h3 id="u5E38_u7528_u64CD_u4F5C"><a href="#u5E38_u7528_u64CD_u4F5C" class="headerlink" title="常用操作"></a>常用操作</h3><p>例子摘自<a href="http://www.jianshu.com/p/e10e5ca413b7" target="_blank" rel="external">最快让你上手ReactiveCocoa之进阶篇</a> 和 <a href="http://ios.jobbole.com/82356/" target="_blank" rel="external">这样好用的ReactiveCocoa,根本停不下来</a>(PS: 如果知道原文地址请告知 :) )</p>
<h5 id="u6620_u5C04"><a href="#u6620_u5C04" class="headerlink" title="映射"></a>映射</h5><ul>
<li>map 将信号的值映射成一个新值</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UITextField</span> *textField= [[<span class="built_in">UITextField</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">30</span>)];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:textField];</span><br><span class="line">    </span><br><span class="line">[[[textField rac_textSignal] map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">@"map 过的值"</span>;</span><br><span class="line">&#125;] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">  <span class="comment">// 处理 map 之后的值</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<ul>
<li>flattenMap 将信号映射成新的信号</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">   NSLog<span class="list">(@<span class="string">"第一步操作"</span>)</span><span class="comment">;</span></span><br><span class="line">   <span class="collection">[subscriber sendNext:@<span class="string">"第二步操作"</span>]</span><span class="comment">;</span></span><br><span class="line">   <span class="collection">[subscriber sendCompleted]</span><span class="comment">;</span></span><br><span class="line">   return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> flattenMap:<span class="comment">^RACStream</span> *<span class="list">(<span class="keyword">NSString*</span> value)</span> <span class="collection">&#123;</span><br><span class="line">   return <span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">       NSLog<span class="list">(@<span class="string">"现在进行的是: %@"</span>,value)</span><span class="comment">;</span></span><br><span class="line">       <span class="collection">[subscriber sendNext:@<span class="string">"操作完毕"</span>]</span><span class="comment">;</span></span><br><span class="line">       <span class="collection">[subscriber sendCompleted]</span><span class="comment">;</span></span><br><span class="line">       return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">   &#125;</span>]</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">   // x = 操作完毕</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="u7EC4_u5408"><a href="#u7EC4_u5408" class="headerlink" title="组合"></a>组合</h4><ul>
<li>concat 按顺序拼接信号,并且有顺序地接收信号</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal <span class="string">createSignal:</span>^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber <span class="string">sendNext:</span>@<span class="string">"我先做完才能做 B"</span>];</span><br><span class="line">   [subscriber sendCompleted];</span><br><span class="line">   <span class="keyword">return</span> nil;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">RACSignal *signalB = [RACSignal <span class="string">createSignal:</span>^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber <span class="string">sendNext:</span>@<span class="string">"我要等 A 做完了才能开始"</span>];</span><br><span class="line">   [subscriber sendCompleted];</span><br><span class="line">   <span class="keyword">return</span> nil;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">[[signalA <span class="string">concat:</span>signalB] <span class="string">subscribeNext:</span>^(id x) &#123;</span><br><span class="line">   <span class="comment">// 输出</span></span><br><span class="line">   <span class="comment">// 我先做完才能做 B</span></span><br><span class="line">   <span class="comment">// 我要等 A 做完了才能开始</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<ul>
<li>then 用于连接多个信号当前一个信号结束,开始下一个信号.</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[<span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">   NSLog<span class="list">(@<span class="string">"第一步"</span>)</span><span class="comment">;</span></span><br><span class="line">   <span class="collection">[subscriber sendCompleted]</span><span class="comment">;</span></span><br><span class="line">   return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> then:<span class="comment">^RACSignal</span> *<span class="collection">&#123;</span><br><span class="line">   return <span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">       NSLog<span class="list">(@<span class="string">"第二步"</span>)</span><span class="comment">;</span></span><br><span class="line">       <span class="collection">[subscriber sendCompleted]</span><span class="comment">;</span></span><br><span class="line">       return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">   &#125;</span>]</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> then:<span class="comment">^RACSignal</span> *<span class="collection">&#123;</span><br><span class="line">   return <span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">       NSLog<span class="list">(@<span class="string">"第三步"</span>)</span><span class="comment">;</span></span><br><span class="line">       <span class="collection">[subscriber sendCompleted]</span><span class="comment">;</span></span><br><span class="line">       return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">   &#125;</span>]</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> subscribeCompleted:<span class="comment">^&#123;</span><br><span class="line">   NSLog(@"第四步");</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>merge 将多个信号合并为一个,任何一个信号发出就会调用</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber sendNext:@<span class="string">"信号一"</span>];</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber sendNext:@<span class="string">"信号二"</span>];</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="string">[[RACSignal merge:@[signalA, signalB]]</span> subscribeNext:^(id x) &#123;</span><br><span class="line">  </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<ul>
<li>zipWith 将多个信号合并为一个多个信号发出就会调用,接受的值为一个元组</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal <span class="string">createSignal:</span>^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber <span class="string">sendNext:</span>@<span class="string">"signalA"</span>];</span><br><span class="line">   <span class="keyword">return</span> nil;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">RACSignal *signalB = [RACSignal <span class="string">createSignal:</span>^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber <span class="string">sendNext:</span>@<span class="string">"signalB"</span>];</span><br><span class="line">   <span class="keyword">return</span> nil;</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">[[signalA <span class="string">zipWith:</span>signalB] <span class="string">subscribeNext:</span>^(id x) &#123;</span><br><span class="line">   </span><br><span class="line">   NSLog(@<span class="string">"%@"</span>,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<ul>
<li>reduce 把信号发出元组的值聚合成一个值</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal <span class="string">createSignal:</span>^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber <span class="string">sendNext:</span>@<span class="string">"signalA"</span>];</span><br><span class="line">   <span class="keyword">return</span> nil;</span><br><span class="line">&#125;];</span><br><span class="line">RACSignal *signalB = [RACSignal <span class="string">createSignal:</span>^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   [subscriber <span class="string">sendNext:</span>@<span class="string">"signalB"</span>];</span><br><span class="line">   <span class="keyword">return</span> nil;</span><br><span class="line">&#125;];</span><br><span class="line">[[RACSignal <span class="string">combineLatest:</span>@[sugarSignal, waterSignal] <span class="string">reduce:</span>^id (NSString *str1, NSString *str2)&#123;</span><br><span class="line">   <span class="keyword">return</span> [str1 <span class="string">stringByAppendingString:</span>str2];</span><br><span class="line">&#125;] <span class="string">subscribeNext:</span>^(id x) &#123;</span><br><span class="line">	<span class="comment">// 输出 "str1str2"</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="u8FC7_u6EE4"><a href="#u8FC7_u6EE4" class="headerlink" title="过滤"></a>过滤</h4><ul>
<li>filter 过滤信号</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[textField rac_textSignal]</span> filter:<span class="comment">^BOOL</span><span class="list">(<span class="keyword">id</span> value)</span> <span class="collection">&#123;</span><br><span class="line">   return textField.text.length &gt; <span class="number">6</span> ? YES : NO;</span><br><span class="line">&#125;</span>]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">  // 之后当 textField.text 的长度大于六位才会接收到信号</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>ignore 忽略完某些值的信</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[textField rac_textSignal]</span> ignore:@<span class="string">"我是被忽略的值"</span>]</span> </span><br><span class="line">subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>distinctUntilChanged 只有当与上一个信号值不同时,才会发出信号</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[textField rac_textSignal]</span> distinctUntilChanged]</span> </span><br><span class="line">subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>take 取 N 次的信号</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *signal = [RACSubject subject];</span><br><span class="line">[[signal <span class="string">take:</span><span class="number">1</span>] <span class="string">subscribeNext:</span>^(id x) &#123;</span><br><span class="line">	<span class="comment">// 只会接受一次信号</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signal <span class="string">sendNext:</span>@<span class="number">1</span>];</span><br><span class="line">[signal <span class="string">sendNext:</span>@<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>takeLast 取最后 N 次的信号,订阅者必须调用完成.</li>
</ul>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSubject *signal = <span class="comment">[RACSubject subject]</span>;</span><br><span class="line"><span class="comment">[<span class="comment">[signal takeLast:1]</span> subscribeNext:^(id x) &#123;</span><br><span class="line">	// 只会接受最后一次信号</span><br><span class="line">&#125;]</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">[signal sendNext:@1]</span>;</span><br><span class="line"><span class="comment">[signal sendNext:@2]</span>;</span><br><span class="line"><span class="comment">[signal sendCompleted]</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>takeUntil 监听信号直到某个信号执行完成</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[[textField rac_textSignal]</span> <span class="tag">takeUntil</span><span class="pseudo">:self</span><span class="class">.rac_willDeallocSignal</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>引用<a href="http://limboy.me/ios/2014/06/06/deep-into-reactivecocoa2.html" target="_blank" rel="external">limboy 大神的一个例子</a><br>它的常用场景之一是处理cell的button的点击事件,比如点击Cell的详情按钮,需要push一个VC,就可以这样:</p>
</blockquote>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[cell.detailButton</span><br><span class="line">    rac_signalForControlEvents:UIControlEventTouchUpInside]</span></span><br><span class="line">    takeUntil:cell.rac_prepareForReuseSignal]</span></span><br><span class="line">    subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">        // generate and push ViewController</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>skip 跳过 N 个信号</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[textField rac_textSignal]</span> skip:1]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>takeUntilBlock:(BOOL (^)(id x)) 对于每个信号的值,运行block,当block返回YES时停止.</li>
<li>takeWhileBlock:(BOOL (^)(id x)) 对于每个信号的值,运行block,当block返回NO时停止.</li>
<li>skipUntilBlock:(BOOL (^)(id x)) 对于每个信号的值,运行block,当block返回YES时停止跳过.</li>
<li>skipWhileBlock:(BOOL (^)(id x)) 对于每个信号的值,运行block,当block返回NO时停止跳过.</li>
</ul>
<h4 id="u79E9_u5E8F"><a href="#u79E9_u5E8F" class="headerlink" title="秩序"></a>秩序</h4><ul>
<li>doNext 执行 Next 之前,会先执行这个Block</li>
<li>doCompleted 执行 sendCompleted 之前,会先执行这个Block</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[<span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">  <span class="collection">[subscriber sendNext:@<span class="number">1</span>]</span><span class="comment">;</span></span><br><span class="line">  <span class="collection">[subscriber sendCompleted]</span><span class="comment">;</span></span><br><span class="line">  return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> doNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">// 执行<span class="collection">[subscriber sendNext:@<span class="number">1</span>]</span><span class="comment">;之前会调用这个Block</span></span><br><span class="line">  NSLog<span class="list">(@<span class="string">"doNext"</span>)</span><span class="comment">;;</span></span><br><span class="line">&#125;</span>]</span> doCompleted:<span class="comment">^&#123;</span><br><span class="line">   // 执行[subscriber sendCompleted];之前会调用这个Block</span><br><span class="line">  NSLog(@"doCompleted");;</span><br><span class="line"></span><br><span class="line">&#125;</span>]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line"></span><br><span class="line">  NSLog<span class="list">(@<span class="string">"%@"</span>,x)</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="u65F6_u95F4"><a href="#u65F6_u95F4" class="headerlink" title="时间"></a>时间</h4><ul>
<li>timeout 超时</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">   return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> timeout:10 onScheduler:<span class="collection">[RACScheduler currentScheduler]</span>]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span> error:^<span class="list">(<span class="keyword">NSError</span> *error)</span> <span class="collection">&#123;</span><br><span class="line">   // 十秒后调用</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>interval 定时</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[RACSignal interval:1 onScheduler:<span class="collection">[RACScheduler currentScheduler]</span>]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>delay 延迟调用 sendNext</li>
</ul>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">[<span class="collection">[RACSignal createSignal:<span class="comment">^RACDisposable</span> *<span class="list">(<span class="keyword">id&lt;RACSubscriber&gt;</span> subscriber)</span> <span class="collection">&#123;</span><br><span class="line">   <span class="collection">[subscriber sendNext:@<span class="string">"signal"</span>]</span><span class="comment">;</span></span><br><span class="line">   return <span class="literal">nil</span><span class="comment">;</span></span><br><span class="line">&#125;</span>]</span> delay: <span class="number">10</span>]</span> subscribeNext:^<span class="list">(<span class="keyword">id</span> x)</span> <span class="collection">&#123;</span><br><span class="line">   // <span class="number">10</span> 秒后接收</span><br><span class="line">&#125;</span>]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="u91CD_u590D"><a href="#u91CD_u590D" class="headerlink" title="重复"></a>重复</h4><ul>
<li>retry 重试,只要失败,就会重新执行创建信号中的block,直到成功.</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">[[[RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       <span class="keyword">if</span> (i == <span class="number">10</span>) &#123;</span><br><span class="line">           [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@"接收到错误"</span>);</span><br><span class="line">           [subscriber sendError:<span class="literal">nil</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       i++;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] retry] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"></span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<ul>
<li>replay 重放,当一个信号被多次订阅,只发送第一次的数据</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>; </span><br><span class="line">	[subscriber sendNext:@(a)];</span><br><span class="line">	a ++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] replay];</span><br><span class="line">    </span><br><span class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"第一个订阅者%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">[signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"第二个订阅者%@"</span>,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个输出都为 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>throttle 节流,当某个信号发送比较频繁时可以隔一段时间获取信号的最新内容</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在十秒内不接受任何信号内容,十秒后获取最后发送的信号内容</span></span><br><span class="line"><span class="attr_selector">[[[RACSubject subject]</span> <span class="tag">throttle</span><span class="pseudo">:10</span>] <span class="tag">subscribeNext</span>:^(id x) &#123;</span><br><span class="line">   </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="u8865_u5145"><a href="#u8865_u5145" class="headerlink" title="补充"></a>补充</h4><p>听了<a href="https://github.com/DeveloperLx" target="_blank" rel="external">DeveloperLx</a>关于 ReactiveCocoa 的分享,记录一下一个优化即时搜索的代码段,很值得学习.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UITextField</span> * textField = [[<span class="built_in">UITextField</span> alloc]init];</span><br><span class="line">textField<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> cyanColor];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:textField];</span><br><span class="line">   </span><br><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line">[textField mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">  @strongify(<span class="keyword">self</span>);</span><br><span class="line">  make<span class="variable">.size</span><span class="variable">.mas_equalTo</span>(<span class="built_in">CGSizeMake</span>(<span class="number">180</span>, <span class="number">40</span>));</span><br><span class="line">  make<span class="variable">.center</span><span class="variable">.equalTo</span>(<span class="keyword">self</span><span class="variable">.view</span>);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//throttle 后面是个时间 表示rac_textSignal发送消息，0.3秒内没有再次发送就会相应，若是0.3内又发送消息了，便会在新的信息处重新计时</span></span><br><span class="line"><span class="comment">//distinctUntilChanged 表示两个消息相同的时候，只会发送一个请求</span></span><br><span class="line"><span class="comment">//ignore 表示如果消息和ignore后面的消息相同，则会忽略掉这条消息，不让其发送</span></span><br><span class="line">[[[[[[textField<span class="variable">.rac_textSignal</span> throttle:<span class="number">0.3</span>] distinctUntilChanged] ignore:<span class="string">@""</span>] map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//  network request</span></span><br><span class="line">      [subscriber sendNext:value];</span><br><span class="line">      [subscriber sendCompleted];</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//  cancel request</span></span><br><span class="line">      &#125;];</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;]switchToLatest] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">  </span><br><span class="line">  LxDBAnyVar(x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>这样做给服务器减小了很多的压力，更是节省了我们大量的代码。 其中我们用map建立了一个新的信号，我们知道textField的改变是一个信号， map就是在这个信号上，又加了一个信号，即signal of signals。<br>订阅者所打印的消息x则是，map发出的信号。我们可以再map中发送新的信号，以及取消信号disposable.<br>当我们用map发送信号的时候，我们则需要使用 switchToLatest这个参数来获取最后一个信号，也就是我们最后所打印的x，就是map最后发错的这个信号。</p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>未完待续</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="ReactiveCocoa__u662F_u4EC0_u4E48"><a href="#ReactiveCocoa__u662F_u4EC0_u4E48" class="headerlink" title="ReactiveCocoa 是什么"></a>React]]>
    </summary>
    
      <category term="ReactiveCocoa" scheme="http://broccolii.github.io/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 中的 RunLoop]]></title>
    <link href="http://broccolii.github.io/2015/01/31/iOS_Runloop/"/>
    <id>http://broccolii.github.io/2015/01/31/iOS_Runloop/</id>
    <published>2015-01-30T18:11:12.000Z</published>
    <updated>2016-01-11T09:14:22.000Z</updated>
    <content type="html"><![CDATA[<p>最近听了 <a href="http://blog.sunnyxx.com/" target="_blank" rel="external">sunnyxx</a> 大神关于 RunLoop 的分享会,总结一下 iOS 中的 RunLoop.</p>
<h3 id="u4EC0_u4E48_u662F_RunLoop"><a href="#u4EC0_u4E48_u662F_RunLoop" class="headerlink" title="什么是 RunLoop"></a>什么是 RunLoop</h3><p>RunLoop 顾名思义指的是运行的循环,指一个事件处理的循环,用来不停地调动工作以及处理输入事件.通俗点说RunLoop 好比一个 While 循环,不停地在监听事件,处理事件.不过 Apple 在此基础上进行了大量优化,使得大大减少了 CPU 的占用.比如给 RunLoop 添加了不同事件源,不同的 mode,使其在不工作时休眠等.不过 RunLoop 并不是 iOS / OS X 所特有的,在任何平台的多线程编程中,为了处理异步消息,都有这样一个类似消息队列的概念,比如 Android 中的 Looper.</p>
<h3 id="RunLoop__u548C_u7EBF_u7A0B_u7684_u5173_u7CFB"><a href="#RunLoop__u548C_u7EBF_u7A0B_u7684_u5173_u7CFB" class="headerlink" title="RunLoop 和线程的关系"></a>RunLoop 和线程的关系</h3><p>RunLoop 和 iOS 的线程是紧密相连的,在 iOS 中任何线程,如果要监听处理一些事件都需要产生一个 RunLoop 的对象.主线程中的 RunLoop 在 App 启动时产生并运行,子线程中需要手动创建并运行(<code>[NSRunLoop currentRunLoop];</code> 会判断是否有 RunLoop ,而自动创建).也就是说每一个线程中都可以获取 RunLoop 对象，但是并不是每一个线程中都有 RunLoop 的实例对象.</p>
<h3 id="RunLoop_mode"><a href="#RunLoop_mode" class="headerlink" title="RunLoop mode"></a>RunLoop mode</h3><p>RunLoop 运行时,它会显式或隐式地指定一个mode.并只能以一种固定的模式运行,只会监听这个 mode 下添加的 Time Source 和 Input Source.如果这个模式下没有添加事件源,RunLoop会立刻退出.大多数时候,Run Loop 都是运行在系统定义的默认模式上.同理也只有与这个 mode 关联的 observer 才会被通知.和其他 mode 关联的事件源只有当 Run Loop 运行在对应的 mode 下才会分发相应的事件过来，否则就处于暂停状态。<br>在 Cocoa 中定义的 mode 主要的是那么几种:</p>
<blockquote>
<ol>
<li>CFRunLoopDefaultMode: 这个是默认 mode,也是空闲状态.主线程通常在这个 mode 下运行的</li>
<li>UITrackingRunLoopMode: 当 ScrollView 滚动时候的模式</li>
<li>UIInitializationRunLoopMode: 在刚启动程序时进入的第一个 mode,启动完成后就不再使用</li>
<li>GSEventReceiveRunLoopMode: 接受系统事件的内部的 mode</li>
<li>CFRunLoopCommonModes: 这是一个集合,包含了 1,2 两种模式</li>
</ol>
</blockquote>
<p>需要注意的是 CFRunLoopCommonModes 其实并不是一种 mode,而是一个集合.因此 RunLoop 并不能在CFRunLoopCommonModes下运行.但是你可以将需要输入的事件源添加为这个 mode,这样无论 RunLoop 运行在哪个 mode 下都可以响应这个输入事件,否则这个事件将不会得到响应.</p>
<p>这里我们可能会遇到一些 RunLoop 的坑:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSTimer <span class="string">scheduledTimerWithTimeInterval:</span><span class="number">1.0</span> <span class="string">target:</span>self <span class="string">selector:</span><span class="annotation">@selector</span>(foo) <span class="string">userInfo:</span>nil <span class="string">repeats:</span>YES];</span><br></pre></td></tr></table></figure>
<p>一般情况下我们会使用这个方法来添加一个定时器,但是我们用这个方法创建的 NSTimer 会被加到 CFRunLoopDefaultMode 中,此时,如果页面开始滚动 主线程 RunLoop 的 mode 会切换到 UITrackingRunLoopMode,我们刚刚创建的 NSTimer 就不会运行.我们可以将新建的 NSTimer 放到<br> CFRunLoopCommonModes 中,这样不论在什么状态都是可以执行的.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *timer = [NSTimer <span class="string">timerWithTimeInterval:</span><span class="number">1.0</span> <span class="string">target:</span>self <span class="string">selector:</span><span class="annotation">@selector</span>(foo) <span class="string">userInfo:</span>nil <span class="string">repeats:</span>YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] <span class="string">addTimer:</span>timer <span class="string">forMode:</span>NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>
<h3 id="RunLoop_sources"><a href="#RunLoop_sources" class="headerlink" title="RunLoop sources"></a>RunLoop sources</h3><p>下图展示了 RunLoop 的模型: 可以看出 RunLoop 是线程中的一个循环,并接收两个事件源的消息:<br>Input sources 和 Timer sources<br><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg" alt=""><br><strong>Input sources:</strong><br>Input source 用来投递异步消息,通常消息来自另外的线程或者程序.<br>消息类型分为以下三种:</p>
<p><em>1) Port Input Source</em></p>
<p>Cocoa 和 Core Foundation 提供了 Mach Port 用于线程或进程间的通信.<br>如果要建立和 NSMachPort 对象的本地连接,你需要创建端口对象并加入主线程的 RunLoop 里.当运行子线程的时候,你传递端口对象到子线程的入口.子线程通过端口对象将消息传入主线程.</p>
<p>首先在主线程建立端口对象,并在次线程的启动时将端口对象传入:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置主线程 port,子线程通过此端口发送消息给主线程</span></span><br><span class="line"><span class="built_in">NSPort</span> *myPort = [<span class="built_in">NSMachPort</span> port];</span><br><span class="line"><span class="keyword">if</span> (myPort) &#123;</span><br><span class="line">    myPort<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:myPort forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动子线程,并传入端口信息</span></span><br><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(launchThreadWithPort:) toTarget:	 [MyWorkerClass class] withObject:myPort];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>2) Cocoa Perform Selector Sources</em></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>performSelectorOnMainThread:<span class="params">(<span class="variable">SEL</span>)</span>aSelector withObject:<span class="params">(nullable id)</span>arg waitUntilDone:<span class="params">(<span class="variable">BOOL</span>)</span>wait modes:<span class="params">(nullable <span class="variable">NSArray</span>&lt;<span class="variable">NSString</span> *&gt; *)</span>array;</span><br><span class="line">- <span class="params">(void)</span>performSelectorOnMainThread:<span class="params">(<span class="variable">SEL</span>)</span>aSelector withObject:<span class="params">(nullable id)</span>arg waitUntilDone:<span class="params">(<span class="variable">BOOL</span>)</span>wait;</span><br><span class="line">- <span class="params">(void)</span>performSelector:<span class="params">(<span class="variable">SEL</span>)</span>aSelector onThread:<span class="params">(<span class="variable">NSThread</span> *)</span>thr withObject:<span class="params">(nullable id)</span>arg waitUntilDone:<span class="params">(<span class="variable">BOOL</span>)</span>wait modes:<span class="params">(nullable <span class="variable">NSArray</span>&lt;<span class="variable">NSString</span> *&gt; *)</span>array NS_AVAILABLE<span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span>;</span><br><span class="line">- <span class="params">(void)</span>performSelector:<span class="params">(<span class="variable">SEL</span>)</span>aSelector onThread:<span class="params">(<span class="variable">NSThread</span> *)</span>thr withObject:<span class="params">(nullable id)</span>arg waitUntilDone:<span class="params">(<span class="variable">BOOL</span>)</span>wait NS_AVAILABLE<span class="params">(<span class="number">10</span>_5, <span class="number">2</span>_0)</span>;</span><br><span class="line">- <span class="params">(void)</span>performSelector:<span class="params">(<span class="variable">SEL</span>)</span>aSelector withObject:<span class="params">(nullable id)</span>anArgument afterDelay:<span class="params">(<span class="variable">NSTimeInterval</span>)</span>delay inModes:<span class="params">(<span class="variable">NSArray</span>&lt;<span class="variable">NSString</span> *&gt; *)</span>modes;</span><br><span class="line">- <span class="params">(void)</span>performSelector:<span class="params">(<span class="variable">SEL</span>)</span>aSelector withObject:<span class="params">(nullable id)</span>anArgument afterDelay:<span class="params">(<span class="variable">NSTimeInterval</span>)</span>delay;</span><br><span class="line">+ <span class="params">(void)</span>cancelPreviousPerformRequestsWithTarget:<span class="params">(id)</span>aTarget selector:<span class="params">(<span class="variable">SEL</span>)</span>aSelector object:<span class="params">(nullable id)</span>anArgument;</span><br><span class="line">+ <span class="params">(void)</span>cancelPreviousPerformRequestsWithTarget:<span class="params">(id)</span>aTarget;</span></span><br></pre></td></tr></table></figure>
<p>这些 API 中,最后两个是取消当前线程中的 aSelector 调用,其他的 API 是在当前线程执行指定的 aSelector</p>
<p><strong>Timer source:</strong></p>
<p>Timer Source 类型的事件源,就是创建Timer添加到RunLoop中.在Cocoa里,使用NSTimer创建定时器加入 RunLoop,在 Core Foundation 里使用 CFRunLoopTimerRef 类型,本质上 NSTimer 是CFRunLoopTimerRef的简单扩展.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *timer = [NSTimer <span class="string">timerWithTimeInterval:</span><span class="number">1.0</span> <span class="string">target:</span>self <span class="string">selector:</span><span class="annotation">@selector</span>(foo) <span class="string">userInfo:</span>nil <span class="string">repeats:</span>YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] <span class="string">addTimer:</span>timer <span class="string">forMode:</span>NSRunLoopCommonModes]</span><br></pre></td></tr></table></figure>
<h3 id="RunLoop_Observer"><a href="#RunLoop_Observer" class="headerlink" title="RunLoop Observer"></a>RunLoop Observer</h3><p>对比上面说的 sources,它们是在特定的同步事件或异步事件发生时被触发,RunLoop observer 就不一样了,它是在 RunLoop 执行自己的代码到某一个指定状态时被触发.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>),</span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>),</span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>),</span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">5</span>),</span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">6</span>),</span><br><span class="line">    kCFRunLoopExit = (<span class="number">1U</span>L &lt;&lt; <span class="number">7</span>),</span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopObserverContext</span>  context = &#123;<span class="number">0</span>, (__bridge <span class="keyword">void</span> *)(<span class="keyword">self</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreate</span>(k<span class="built_in">CFAllocatorDefault</span>, k<span class="built_in">CFRunLoopBeforeTimers</span>, <span class="literal">YES</span>, <span class="number">0</span>, &amp;runLoopObserver, &amp;context);</span><br><span class="line"><span class="keyword">if</span> (observer) &#123;</span><br><span class="line">	<span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), observer, k<span class="built_in">CFRunLoopCommonModes</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近听了 <a href="http://blog.sunnyxx.com/" target="_blank" rel="external">sunnyxx</a> 大神关于 RunLoop 的分享会,总结一下 iOS 中的 RunLoop.</p>
<h3 id="u4E]]>
    </summary>
    
      <category term="RunLoop" scheme="http://broccolii.github.io/tags/RunLoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 中的多线程]]></title>
    <link href="http://broccolii.github.io/2014/09/29/iOS_multithreading/"/>
    <id>http://broccolii.github.io/2014/09/29/iOS_multithreading/</id>
    <published>2014-09-29T15:56:35.000Z</published>
    <updated>2016-01-11T06:51:45.000Z</updated>
    <content type="html"><![CDATA[<p>整理了一下 iOS 开发中会遇到的几种多线程.</p>
<h3 id="iOS__u4E2D_u7684_u591A_u7EBF_u7A0B_u7F16_u7A0B"><a href="#iOS__u4E2D_u7684_u591A_u7EBF_u7A0B_u7F16_u7A0B" class="headerlink" title="iOS 中的多线程编程"></a>iOS 中的多线程编程</h3><p>iOS 中的多线程分为以下三种: NSThread, NSOperation/NSOperationQueue, GCD. 其中 NSOperation/NSOperationQueue 是对 GCD 的面向对象封装.</p>
<h3 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h3><h3 id="u7EBF_u7A0B_/__u8FDB_u7A0B"><a href="#u7EBF_u7A0B_/__u8FDB_u7A0B" class="headerlink" title="线程 / 进程"></a>线程 / 进程</h3><ul>
<li>进程(Process):操作系统进行资源分配和调度的基本单位,计算机中已运行程序的实体.</li>
<li>线程(thread):操作系统进行运算调度的最小单位,它被包含在进程之中,是进程中的实际运作单位.一个进程中至少包含一条线程,即主线程.</li>
</ul>
<h4 id="u540C_u6B65_/__u5F02_u6B65"><a href="#u540C_u6B65_/__u5F02_u6B65" class="headerlink" title="同步 / 异步"></a>同步 / 异步</h4><ul>
<li>同步:同步操作会等待操作执行完成后,再继续执行接下来的代码.(会堵塞当前线程)    </li>
<li>异步:异步操作在调用后立即返回,不会等待操作的执行结果.(不会堵塞当前线程)</li>
</ul>
<h4 id="u4E32_u884C_u961F_u5217_/__u5E76_u884C_u961F_u5217"><a href="#u4E32_u884C_u961F_u5217_/__u5E76_u884C_u961F_u5217" class="headerlink" title="串行队列 / 并行队列"></a>串行队列 / 并行队列</h4><ul>
<li>队列: 队列 (queue),是先进先出（FIFO, First-In-First-Out）的线性表.</li>
<li>串行队列: 串行队列是指队列中的任务是按照先后顺序一个接一个地执行的,队首的任务执行后才会执行其后的任务,直至执行到队尾的任务.</li>
<li>并行队列:并行队列是指队列中的任务可以同时地执行,即开始执行队首的任务后,不必等其执行完毕就可以接着开始执行队首之后的任务,因此在某一时刻可能存在同时执行的多个任务.</li>
</ul>
<p><strong>在串行队列中进行异步操作,会发生什么?</strong></p>
<blockquote>
<ol>
<li>加入的串行队列是手动创建的,那么会另开线程执行,从而不会堵塞当前线程.</li>
<li>如果加入的是当前线程的串行队列,那么会堵塞当前线程.比如: 将异步操作放到 main 队列(通过 GCD 的 <code>dispatch_get_main_queue()</code> 获取).</li>
</ol>
</blockquote>
<p><strong>在并行队列中进行同步操作,会发生什么?</strong><br>直接堵塞当前线程,直至同步操作执行完.</p>
<p>详细细节请看<a href="http://www.cnblogs.com/dsxniubility/p/4296937.html" target="_blank" rel="external">董铂然的Blog</a><br>下图表<a href="https://github.com/ChenYilong/ParseSourceCodeStudy/blob/master/01_Parse的多线程处理思路/GCD扫盲篇.md" target="_blank" rel="external">引用自 ChenYilong 的 GCD 扫盲篇</a></p>
<table>
<thead>
<tr>
<th>—</th>
<th>同步</th>
<th>异步 </th>
</tr>
</thead>
<tbody>
<tr>
<td>串行队列</td>
<td>不会新建线程，依然在当前线程上<p></p>类似同步锁，是同步锁的替代方案<p></p>✅ 常用</td>
<td>会新建线程，只开一条线程<p></p>一条线程就够了<p></p> 每次使用 createDispatch 方法就会新建一条线程，多次调用该方法，会创建多条线程，多条线程间会并行执行</td>
</tr>
<tr>
<td>并行队列</td>
<td>不会新建线程，依然在当前线程上<p></p></td>
<td>会新建线程，可以开多条线程<p></p> iOS7-SDK 时代一般是5、6条， iOS8-SDK 以后可以50、60条 <p></p> ✅ 常用</td>
</tr>
</tbody>
</table>
<h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><p>在 iOS 中使用 NSThread 对象建立一个线程非常方便,但是线程的生命周期需要程序员手动管理,也不便于管理多个线程.<br><strong>创建&amp;启动</strong><br><em>两种显式调用</em><br>1.实例方法</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSThread *thread = [[NSThread alloc] <span class="string">initWithTarget:</span>self <span class="string">selector:</span><span class="annotation">@selector</span>(<span class="string">doSomething:</span>) <span class="string">object:</span>nil];</span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure>
<p>2.类方法</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSThread <span class="string">detachNewThreadSelector:</span><span class="annotation">@selector</span>(<span class="string">doSomething:</span>) <span class="string">toTarget:</span>self <span class="string">withObject:</span>nil];</span><br></pre></td></tr></table></figure>
<p><em>隐式调用</em></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self <span class="string">performSelectorInBackground:</span><span class="annotation">@selector</span>(<span class="string">doSomething:</span>) <span class="string">withObject:</span>nil];</span><br></pre></td></tr></table></figure>
<p><strong>一些常用的方法</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得当前线程</span></span><br><span class="line">+ (<span class="built_in">NSThread</span> *)currentThread;</span><br><span class="line"><span class="comment">// 线程休眠</span></span><br><span class="line">+ (<span class="keyword">void</span>)sleepForTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti;</span><br><span class="line"><span class="comment">// 获取主线程</span></span><br><span class="line">+ (<span class="built_in">NSThread</span> *)mainThread;</span><br><span class="line"><span class="comment">// 判断当前线程是否主线程</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isMainThread;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)isMainThread;</span><br><span class="line"><span class="comment">// 判断线程是否正在运行</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isExecuting;</span><br><span class="line"><span class="comment">// 判断线程是否已结束</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isFinished;</span><br></pre></td></tr></table></figure>
<h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>GCD 指的是 Grand Central Dispatch, 是 Apple 提供的一个多核编程的解决方案.GCD 是基于 C 语言的框架,可以充分利用多核,是 Apple 推荐使用的多线程技术.他不需要像 NSThread 一样需要手动管理线程的生命周期,它会自动管理.<br><strong>GCD 中的队列</strong></p>
<ul>
<li>串行队列</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"serialQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure>
<ul>
<li>并行队列</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"concurrentQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>
<p>还有两个特殊的队列:</p>
<ul>
<li>main 队列(串行队列)</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t mainQueue = <span class="function"><span class="title">dispatch_get_main_queue</span><span class="params">()</span></span>；</span><br></pre></td></tr></table></figure>
<p>和 NSThread 中的 <code>+ (NSThread *)mainThread;</code> 一样,用于获取 main 队列, 即 当前进程的主线程.</p>
<blockquote>
<p>在主队列里面执行同步执行任务会造成死锁现象 <a href="http://www.brighttj.com/ios/ios-gcd-deadlock.html" target="_blank" rel="external">详情请看</a></p>
</blockquote>
<ul>
<li>全局队列(并行队列)<br>GCD 默认已经提供了全局的并发队列,供整个应用使用,不需要手动创建.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认权限的 全局队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> defaultQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 有以下几种权限</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_HIGH <span class="number">2</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_DEFAULT <span class="number">0</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_LOW (-<span class="number">2</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span></span><br></pre></td></tr></table></figure>
<p><strong>GCD 的同步/异步</strong><br>在 默认权限下的全局队列 中执行 同步操作</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync<span class="list">(<span class="keyword">dispatch_get_global_queue</span><span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span>, ^&#123;</span><br><span class="line">        // 同步执行的代码</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>在 默认权限下的全局队列 中执行 异步操作</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async<span class="list">(<span class="keyword">dispatch_get_global_queue</span><span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span>, ^&#123;</span><br><span class="line">        // 异步执行的代码</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>dispatch_once</strong><br><code>dispatch_once</code> 保证在 App 运行期间,block 中的代码只执行一次.<br>一般用在实现单例模式上:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例模式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> _instance;</span><br><span class="line"></span><br><span class="line">+ (instancetype)sharedSingleton&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _instance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)allocWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _instance = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone&#123;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>dispatch_after</strong><br><code>dispatch_after</code> 延迟一段时间把一项任务提交到队列中执行,这里需要注意的是: 延时的操作是提交,而不是运行.</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">dispatch_after</span>(<span class="function">dispatch_time</span>(DISPATCH_TIME_NOW, (int64_t)(<span class="number">10</span> * NSEC_PER_SEC)), <span class="tag">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">        <span class="comment">// 延迟操作的代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>dispatch_group</strong><br>我们使用 <code>group</code> 来管理一组异步代码,当它们都执行完后会调用同步或者异步(<code>dispatch_group_notify</code>)回调通知我们.</p>
<p><em>异步回调</em></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">   <span class="comment">// 异步执行的代码</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">   <span class="comment">// 异步执行的代码</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">   <span class="comment">// 异步执行的代码</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(<span class="keyword">group</span>, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">   <span class="comment">// 当所有异步执行的代码执行完毕会进入</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><em>同步回调</em></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">   <span class="comment">// 异步执行的代码</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">   <span class="comment">// 异步执行的代码</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^&#123;</span><br><span class="line">   <span class="comment">// 异步执行的代码</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_wait(<span class="keyword">group</span>, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>
<p>注: <code>dispatch_group_wait</code> 第二个参数表示超时时间. <code>DISPATCH_TIME_FOREVER</code> 表示没有超时时间.</p>
<p><strong>dispatch_apply</strong><br><code>dispatch_apply</code> 用于重复执行同一个任务,以同步的方式把任务追加到队列当中.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">dispatch_apply(<span class="number">3</span>, <span class="built_in">queue</span>, ^(<span class="keyword">size_t</span> index) &#123;</span><br><span class="line">   NSLog(@<span class="string">"%zu"</span>, index);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">01</span>-<span class="number">08</span> <span class="number">18</span>:<span class="number">07</span>:<span class="number">35.923</span> MultithreadingDemo[<span class="number">5626</span>:<span class="number">397563</span>] <span class="number">0</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">01</span>-<span class="number">08</span> <span class="number">18</span>:<span class="number">07</span>:<span class="number">35.923</span> MultithreadingDemo[<span class="number">5626</span>:<span class="number">397617</span>] <span class="number">1</span></span><br><span class="line"><span class="number">2016</span>-<span class="number">01</span>-<span class="number">08</span> <span class="number">18</span>:<span class="number">07</span>:<span class="number">35.923</span> MultithreadingDemo[<span class="number">5626</span>:<span class="number">397831</span>] <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>dispatch_suspend &amp; dispatch_resume</strong><br><code>dispatch_suspend</code> 用于暂停队列<br><code>dispatch_resume</code> 用于恢复队列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 挂起指定的队列</span></span><br><span class="line">dispatch_suspend(<span class="built_in">queue</span>);</span><br><span class="line"><span class="comment">// 恢复指定队列</span></span><br><span class="line">dispatch_resume(<span class="built_in">queue</span>);</span><br></pre></td></tr></table></figure>
<h3 id="NSOperation/NSOperationQueue"><a href="#NSOperation/NSOperationQueue" class="headerlink" title="NSOperation/NSOperationQueue"></a>NSOperation/NSOperationQueue</h3><p>NSOperation/NSOperationQueue 是 Apple 对 GCD 的封装,一个建立在 GCD 的基础之上的,面向对象的解决方案.相对 GCD 来说,使用 NSOperation/NSOperationQueue 会增加一点点额外的开销,与此同时也也获得了更好的灵活性.我们可以指定各个 NSOperation 之间的依赖关系,也可以继承 NSOperation 实现可复用的逻辑模块.</p>
<p><strong>NSOperation</strong><br>NSOperation 用来表示一个需要执行的任务.NSOperation 本身是一个抽象类,不能直接实例化,但是系统提供了两个子类用于封装任务.分别是: NSInvocationOperation 和 NSBlockOperation,同时也可以自定义子类.创建一个 NSOperation 对象后,需要调用 start 方法来启动任务,需要注意的是它会默认在当前队列同步执行.</p>
<ul>
<li>NSInvocationOperation<br>通过一个 object 和 selector 我们可以非常方便地创建一个 NSInvocationOperation.</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInvocationOperation</span> *operation = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(doSomething) object:<span class="literal">nil</span>];</span><br><span class="line">[operation start];</span><br></pre></td></tr></table></figure>
<ul>
<li>NSBlockOperation<br>我们可以使用  NSBlockOperation 来并发执行一个或多个 block. 可以通过NSBlockOperation的实例方法 <code>addExecutionBlock</code> 实现类似 GCD 中的 <code>dispatch_group</code> 的功能.</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> *operation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">   <span class="comment">// do something</span></span><br><span class="line">&#125;];</span><br><span class="line">[operation start];</span><br></pre></td></tr></table></figure>
<p><em>使用有 NSOperation 有什么灵活性呢?</em><br>1.依赖关系<br>NSOperation 有一个非常实用的功能,那就是添加依赖.它可以让一个 operation 只有在它依赖的所有 operation 都执行完成后才能开始执行.</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>addDependency:<span class="params">(<span class="variable">NSOperation</span> *)</span>op;</span></span><br></pre></td></tr></table></figure>
<p>2.队列中的优先级<br>对于被添加到 queue 中的 operation 来说，在 isReady(取决于依赖关系) 状态下,决定它们执行顺序他们在队列中的优先级.默认情况下都是 normal 的,但是我们可以根据需要通过 <code>setQueuePriority:</code> 方法来提高或降低 operation 的队列优先级.有以下几种优先级给我们选择.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">NSOperationQueuePriority</span>) &#123;</span><br><span class="line">	<span class="built_in">NSOperationQueuePriorityVeryLow</span> = -<span class="number">8</span>L,</span><br><span class="line">	<span class="built_in">NSOperationQueuePriorityLow</span> = -<span class="number">4</span>L,</span><br><span class="line">	<span class="built_in">NSOperationQueuePriorityNormal</span> = <span class="number">0</span>,</span><br><span class="line">	<span class="built_in">NSOperationQueuePriorityHigh</span> = <span class="number">4</span>,</span><br><span class="line">	<span class="built_in">NSOperationQueuePriorityVeryHigh</span> = <span class="number">8</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>3.可以在任务执行完进行回调</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[operation1 <span class="built_in">set</span>CompletionBlock:^&#123;</span><br><span class="line">    // <span class="keyword">do</span> something  </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><strong>NSOperationQueue</strong><br>NSOperationQueue 并不像 GCD 中的队列那么复杂.默认都是并行的,通过设置 NSOperationQueue 的 <code>maxConcurrentOperationCount</code> 属性为一.那么它就变成了串行队列.NSOperationQueue 提供了获取 main 队列的方法.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (NSOperationQueue *)<span class="function">mainQueue <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_6, <span class="number">4</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
<p>不过一般情况下我们会使用 </p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue = <span class="comment">[<span class="comment">[NSOperationQueue alloc]</span> init]</span>;</span><br></pre></td></tr></table></figure>
<p>进行初始化创建,然后通过以下三种方法添加任务,如果使用了下面三个方法,那么自动执行了 NSOperation 的 <code>start</code> 方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加一个NSOperation</span></span><br><span class="line">- (<span class="keyword">void</span>)addOperation:(NSOperation *)op;</span><br><span class="line"><span class="comment">// 添加一组NSOperation</span></span><br><span class="line">- (<span class="keyword">void</span>)addOperations:(NSArray&lt;NSOperation *&gt; *)ops waitUntilFinished:(BOOL)<span class="function">wait <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_6, <span class="number">4</span>_0)</span></span>;</span><br><span class="line"><span class="comment">// 以 block 的形式 添加任务(代替 NSBlockOperation)</span></span><br><span class="line">- (<span class="keyword">void</span>)addOperationWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))<span class="function">block <span class="title">NS_AVAILABLE</span><span class="params">(<span class="number">10</span>_6, <span class="number">4</span>_0)</span></span>;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>整理了一下 iOS 开发中会遇到的几种多线程.</p>
<h3 id="iOS__u4E2D_u7684_u591A_u7EBF_u7A0B_u7F16_u7A0B"><a href="#iOS__u4E2D_u7684_u591A_u7EBF_u7A0B_u7F16_u7]]>
    </summary>
    
      <category term="Thread" scheme="http://broccolii.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C 中的 Runtime]]></title>
    <link href="http://broccolii.github.io/2014/07/29/Objective-C_Runtime/"/>
    <id>http://broccolii.github.io/2014/07/29/Objective-C_Runtime/</id>
    <published>2014-07-28T20:12:01.000Z</published>
    <updated>2016-01-12T13:55:06.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Runtime__u662F_u4EC0_u4E48"><a href="#Runtime__u662F_u4EC0_u4E48" class="headerlink" title="Runtime 是什么"></a>Runtime 是什么</h3><p>Objective-C 是基于 C 语言加入了面向对象特性和消息转发机制的动态语言,因此它尽可能地将一些工作从编译链接推迟到运行时.这意味着仅仅有编译器是不够的,还需要一套运行时系统来执行编译后的代码.这个运行时系统就是一个用 C 和汇编写的 Runtime 库,它是 Objective-C 作为一门动态语言的是基础.虽然这些特性在开发中使用的较少，但是理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言,合理的运用还能在系统层面上解决一些技术问题.<br>你可以<a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">这里</a>在下载到 Apple 维护的 Runtime 源码,开始我们的探索.</p>
<h3 id="Runtime_NSObject_/_Class"><a href="#Runtime_NSObject_/_Class" class="headerlink" title="Runtime NSObject / Class"></a>Runtime NSObject / Class</h3><p>我们打开刚刚下载的源码,选择 NSObject.h 这个文件.我们可以看到 NSObject 就是一个包含 isa 指针的结构体:</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="class"><span class="keyword">interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">Class</span> <span class="title">isa</span>  <span class="title">OBJC_ISA_AVAILABILITY</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 Objective-C 语言的内部,每一个对象都有一个名为 isa 的指针,指向该对象的类.每一个类描述了一系列它的实例的特点,包括成员变量的列表,成员函数的列表等.每一个对象都可以接受消息,而对象能够接收的消息列表是保存在它所对应的类中.</p>
</blockquote>
<p>我们现在去 runtime.h 中去看一下 Class 是怎么定义的.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_<span class="built_in">AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的变量是为了兼容 Objective-C 2.0 之前的版本 可以忽略</span></span><br><span class="line"><span class="preprocessor">#if !__OBJC2__</span></span><br><span class="line">    <span class="comment">// 父类</span></span><br><span class="line">    Class super_class                                        OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 类名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 类的版本信息 默认是 0</span></span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 类信息,供运行期间使用的位标示</span></span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 类的实例变量大小</span></span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 存储类的成员变量的链表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 方法定义的链表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 常用方法的缓存</span></span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 协议的链表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br></pre></td></tr></table></figure>
<p>你会发现 Class 类里居然只有一个 isa 指针,刚刚不是说了 isa 是指向该对象的类么?为什么类也会有 isa 呢?根据万物皆对象,其实 Class 也是一个对象, 那么他必须是另一个类的实例化对象,那么这个类就是 <code>元类</code>(metaclass).元类存储着类方法列表,元类的 isa 指针又指向了 <code>根元类</code>(root metaclass).<br>有一张关于 isa 和继承关系的图,可能会让大家理解的更清晰一些:<br><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/Objective-C_Runtime/class-diagram.jpg" alt=""></p>
<p>isa 指针的值是可以被动态修改.iOS 中的 KVO 的实现机制就是将被观察对象的 isa 指针指向一个中间类而不是我们所观察的类,这就是 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" target="_blank" rel="external">isa-swizzling</a>.</p>
<hr>
<p>虽然 Objective-C 2.0 没有暴露,object_class 更多的细节,我们仍然可以从 Objective-C 1.0 的定义中获取我们想要的信息.<br><em>Ivar</em> 表示类的成员变量</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="comment">// 成员变量的名字</span></span><br><span class="line">    <span class="keyword">char</span> *ivar_name                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 成员变量的类型</span></span><br><span class="line">    <span class="keyword">char</span> *ivar_type                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 成员变量在链表中的位置</span></span><br><span class="line">    <span class="keyword">int</span> ivar_offset                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">&#125;                                                            OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br></pre></td></tr></table></figure>
<p><em>Method</em> 表示类的方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">    <span class="comment">// 方法名</span></span><br><span class="line">    SEL method_name                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 静态方法 / 实例方法</span></span><br><span class="line">    <span class="keyword">char</span> *method_types                                       OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="comment">// 方法实现 (函数指针)</span></span><br><span class="line">    IMP method_imp                                           OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">&#125;                                                            OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br></pre></td></tr></table></figure>
<p><em>IMP</em> 其实就是 <code>objc_sendMsg(receiver, selector, arg1, arg2, ...)</code> 的指针</p>
<h3 id="Runtime__u6D88_u606F_u5904_u7406_u673A_u5236"><a href="#Runtime__u6D88_u606F_u5904_u7406_u673A_u5236" class="headerlink" title="Runtime 消息处理机制"></a>Runtime 消息处理机制</h3><p>你是否想过 Objective-C 为什么把对象调用方法称作 <code>消息传递</code>(或 <code>发送消息</code>) (pass a message).其实编译器会将我们的 <code>[receiver selector]</code> 翻译成一个 C 函数调用</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">objc_msgSend</span><span class="params">(receiver, selector)</span></span></span><br></pre></td></tr></table></figure>
<p>也可以添上参数</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">objc_sendMsg</span><span class="params">(receiver, selector, arg1, arg2, ...)</span></span></span><br></pre></td></tr></table></figure>
<p>发送消息之后一般会经过下面几个步骤:</p>
<ol>
<li>通过 receiver 的 isa 指针找到它的 Class </li>
<li>在 Class 的 method list 找 selector </li>
<li>如果 Class 中没到 foo,继续往它的 superclass 中找 </li>
<li>一旦找到 selector 这个函数，就去执行它的实现IMP<br>下图展示了一个方法查找的流程图:</li>
</ol>
<p><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/Objective-C_Runtime/messaging.PNG" alt=""></p>
<p>如果每一个消息都经过这样一个传递链,其实效率是很低.因为 class 往往只有 20% 的函数会被经常调用,如果把经常被调用的函数缓存下来,那可以大大提高函数查询的效率.这也就是 objc_class 中另一个重要成员 objc_cache 做的事情,当再次收到 selector 消息的时候，可以直接在 cache 里找到，避免去遍历 objc_method_list.</p>
<h3 id="Runtime__u6D88_u606F_u8F6C_u53D1_u673A_u5236"><a href="#Runtime__u6D88_u606F_u8F6C_u53D1_u673A_u5236" class="headerlink" title="Runtime 消息转发机制"></a>Runtime 消息转发机制</h3><p>如果走完所有步骤,如果 selector 还是没有被找到会发生什么?程序会在运行时挂掉并抛出 unrecognized selector 的异常?其实在异常抛出前,Runtime 会给你三次拯救程序的机会：</p>
<ul>
<li>Method resolution // 动态方法解析</li>
<li>Fast forwarding        // 消息转发</li>
<li>Normal forwarding // 消息转发</li>
</ul>
<p><img src="https://raw.githubusercontent.com/broccolii/broccolii.github.io/master/images/Objective-C_Runtime/Forwarding.png" alt=""><br><em>Method resolution</em><br>首先，Objective-C 运行时会调用 <code>+resolveInstanceMethod:</code> 或者 <code>+resolveClassMethod:</code>,让你有机会提供一个函数实现.如果你添加了函数并返回 YES,那运行时系统就会重新启动一次消息发送的过程.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSEL &#123;</span><br><span class="line">    <span class="keyword">if</span>(aSEL == <span class="keyword">@selector</span>(foo:))&#123;</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> class], aSEL, (IMP)fooMethod, <span class="string">"v@:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> fooMethod(<span class="keyword">id</span> obj, SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Doing foo"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 resolve 方法没有实现或者 return NO,就会进到下一步 <em>Message Forwarding</em>(消息转发)</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (id)<span class="string">forwardingTargetForSelector:</span>(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span>(aSelector == <span class="annotation">@selector</span>(<span class="string">foo:</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> alternateObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> <span class="string">forwardingTargetForSelector:</span>aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Normal forwarding</em> 你是最后一个实现方法的机会<br>首先它会发送 <code>-methodSignatureForSelector:</code> 消息获得函数的参数和返回值类型.如果 <code>-methodSignatureForSelector:</code> 返回 nil,Runtime 则会发出 <code>-doesNotRecognizeSelector:</code> 消息,程序这时也就挂掉了.<br>如果返回了一个函数签名,Runtime 就会创建一个 <code>NSInvocation</code> 对象并发送 <code>-forwardInvocation:</code> 消息给目标对象<br><code>NSInvocation</code> 实际上就是对一个消息的描述,包括 selector 以及参数等信息.所以你可以在 <code>-forwardInvocation:</code> 里修改传进来的 NSInvocation 对象，然后发送 -invokeWithTarget: 消息给它，传进去一个新的目标</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)<span class="string">methodSignatureForSelector:</span>(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    NSMethodSignature *methodSignature = [<span class="keyword">super</span> <span class="string">methodSignatureForSelector:</span>aSelector];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!methodSignature) &#123;</span><br><span class="line">        methodSignature = [NSMethodSignature <span class="string">signatureWithObjCTypes:</span><span class="string">"v@:*"</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> methodSignature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="typename">void</span>)<span class="string">forwardInvocation:</span>(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    MessageForwarding *messageForwarding = [MessageForwarding <span class="keyword">new</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([messageForwarding <span class="string">respondsToSelector:</span>anInvocation.selector]) &#123;</span><br><span class="line">        [anInvocation <span class="string">invokeWithTarget:</span>messageForwarding];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><em>Method Resolution</em>:由于Method Resolution不能像消息转发那样可以交给其他对象来处理,所以只适用于在原来的类中代替掉.<br><em>Fast Forwarding</em>:它可以将消息处理转发给其他对象,使用范围更广,不只是限于原来的对象.<br><em>Normal Forwarding</em>:它跟Fast Forwarding一样可以消息转发,但它能通过NSInvocation对象获取更多消息发送的信息,例如:target、selector、arguments和返回值等信息.</p>
<h3 id="Method_Swizzling"><a href="#Method_Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h3><p>Objective-C 中的 Method Swizzling 是一项异常强大的技术，它可以允许我们动态地替换方法的实现.当我们想修改系统提供的类时,我们能有什么办法呢？继承类并重写方法是一种可行的办法,但是并不能称为最优解.我们可以通过 Runtime 的 Method Swizzling,它通过交换两个 selector 的 IMP 从而达到<code>张冠李戴</code>的效.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;objc/runtime.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Tracking</span>) </span></span><br><span class="line"> </span><br><span class="line">+ (<span class="keyword">void</span>)load &#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; </span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; </span><br><span class="line">        Class aClass = [<span class="keyword">self</span> class]; </span><br><span class="line"> </span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(viewWillAppear:); </span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(xxx_viewWillAppear:); </span><br><span class="line"> </span><br><span class="line">        Method originalMethod = class_getInstanceMethod(aClass, originalSelector); </span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); </span><br><span class="line">     </span><br><span class="line">        <span class="built_in">BOOL</span> didAddMethod = </span><br><span class="line">            class_addMethod(aClass, </span><br><span class="line">                originalSelector, </span><br><span class="line">                method_getImplementation(swizzledMethod), </span><br><span class="line">                method_getTypeEncoding(swizzledMethod)); </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (didAddMethod) &#123; </span><br><span class="line">            class_replaceMethod(aClass, </span><br><span class="line">                swizzledSelector, </span><br><span class="line">                method_getImplementation(originalMethod), </span><br><span class="line">                method_getTypeEncoding(originalMethod)); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">#pragma mark - Method Swizzling</span></span><br><span class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123; </span><br><span class="line">    [<span class="keyword">self</span> xxx_viewWillAppear:animated]; </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"viewWillAppear: %@"</span>, <span class="keyword">self</span>); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>我们通过 Method Swizzling 替换掉了,系统原本的 <code>viewWillAppear</code>.</p>
<h3 id="Objective-C_Associated_Objects"><a href="#Objective-C_Associated_Objects" class="headerlink" title="Objective-C Associated Objects"></a>Objective-C Associated Objects</h3><p>我们可以用 Category 对已存在的类添加实例方法或类方法,而不适合添加额外的属性.我们可以使用Associated Objects 来给已存在的类 Category 添加自定义的属性.<br>Associated Objects提供三个API来向对象添加、获取和删除关联值：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT <span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy)</span><br><span class="line">OBJC_EXPORT <span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">    __OSX_<span class="built_in">AVAILABLE_STARTING</span>(__MAC_10_6, __IPHONE_3_1);</span><br><span class="line">OBJC_EXPORT <span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object)</span><br><span class="line">    __OSX_<span class="built_in">AVAILABLE_STARTING</span>(__MAC_10_6, __IPHONE_3_1);</span><br></pre></td></tr></table></figure>
<p>有一点需要注意的是 <code>objc_removeAssociatedObjects</code> 这个方法会 remove 掉所有该对象的 Associated Objects, 所以要谨慎使用.下面我们试着给 NSObject 添加一个 <code>associatedObject</code> 属性.<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSObject+AssociatedObject.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">AssociatedObject</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="keyword">id</span> associatedObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="comment">// NSObject+AssociatedObject.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">AssociatedObject</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setAssociatedObject:(<span class="keyword">id</span>)associatedObject</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(associatedObject), associatedObject, OBJC_ASSO<span class="built_in">CIATION_RETAIN_NONATOMIC</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)associatedObject</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>Associated Objects 的 key 要求是唯一并且是常量,而SEL是满足这个要求的,所以上面的采用隐藏参数 <code>_cmd</code> 作为 key.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Runtime__u662F_u4EC0_u4E48"><a href="#Runtime__u662F_u4EC0_u4E48" class="headerlink" title="Runtime 是什么"></a>Runtime 是什么</h3><p>Obje]]>
    </summary>
    
      <category term="Runtime" scheme="http://broccolii.github.io/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Objective-C 中的 Block]]></title>
    <link href="http://broccolii.github.io/2014/07/28/Objective-C_Block/"/>
    <id>http://broccolii.github.io/2014/07/28/Objective-C_Block/</id>
    <published>2014-07-27T17:11:02.000Z</published>
    <updated>2016-01-12T14:17:25.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u4EC0_u4E48_u662F_Block"><a href="#u4EC0_u4E48_u662F_Block" class="headerlink" title="什么是 Block"></a>什么是 Block</h3><p>Block 翻译成中文就是块,顾名思义指的是代码块.与函数类似,有参数,有返回值.只不过是直接实现在另一个函数里的,同时可以获取该函数的局部变量. Block 只是 Objective-C 对闭包的实现.</p>
<blockquote>
<p>讲人话:  Block 就是一段能够在将来被执行的代码. Block 本身就是一个普通的 Objective-C 对象.正因为它是对象，Block 可以被作为参数传递，可以作为返回值从一个方法返回，可以用来给变量赋值</p>
</blockquote>
<h3 id="Block__u7684_u7533_u660E_u5B9A_u4E49"><a href="#Block__u7684_u7533_u660E_u5B9A_u4E49" class="headerlink" title="Block 的申明定义"></a>Block 的申明定义</h3><p>可以先看一下 <a href="http://fuckingblocksyntax.com" target="_blank" rel="external">How Do I Declare A Block in Objective-C?</a><br>Block 的声明格式如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">returnType (^blockName)(parameterTypes) = ^returnType(parameters) <span class="decorator">&#123;...&#125;</span>;</span><br></pre></td></tr></table></figure>
<p>我们实现一个加法功能的 Block</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (^addBlock)(<span class="keyword">int</span> a, <span class="keyword">int</span> b) = ^(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">   <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后像函数一样调用这个 Block </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> add = addBlock(<span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Block__u7684_u53D8_u91CF"><a href="#Block__u7684_u53D8_u91CF" class="headerlink" title="Block 的变量"></a>Block 的变量</h3><p>还记得我们刚刚说过 Block 会获取实现它的函数内的局部变量,并且对这些栈变量进行一次只读拷贝，然后在  Block 块内使用该只读拷贝.</p>
<ol>
<li>只读: 不能被修改值</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)foo &#123;</span><br><span class="line">    <span class="keyword">int</span> stackVariables = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> (^addBlock)(<span class="keyword">int</span> a, <span class="keyword">int</span> b) = ^ <span class="keyword">int</span> (<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        stackVariables++; <span class="comment">// 编译不通过</span></span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> add = addBlock(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.copy: 在定义完 Block 后 修改了 stackVariables 的值, 但是 Block 并不受影响</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)foo &#123;</span><br><span class="line">    <span class="keyword">int</span> stackVariables = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> (^addBlock)(<span class="keyword">int</span> a, <span class="keyword">int</span> b) = ^ <span class="keyword">int</span> (<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"stack variable = %ld"</span>, (<span class="keyword">long</span>)stackVariables);</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改 stackVariables 的值</span></span><br><span class="line">    stackVariables = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> add = addBlock(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要在 Block 中修改局部变量的值, 我们可以使用 __block 关键字来修饰变量,这样就可以在 Block 中修改变量了.对于用 __block 修饰的局部变量，Block 为其生成了一个 Struct 来存储引用地址.具体细节可以看唐巧大神写的<a href="http://blog.devtang.com/blog/2013/07/28/a-look-inside-blocks/" target="_blank" rel="external">谈Objective-C Block的实现</a></p>
<h3 id="retain_cycle"><a href="#retain_cycle" class="headerlink" title="retain cycle"></a>retain cycle</h3><p>Block 使用时,不仔细思量,就很容易出现循环引用,导致内存泄露.那到底什么时候会发生循环引用呢?<br>我们来修改一下刚刚的 Block 将他定义成 当前类的一个属性,同时在 Block 定义时,打印当前类的一个属性</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (^AddBlock)(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AddBlock addBlock;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSString</span> *memberVariable;</span><br><span class="line">...</span><br><span class="line">- (<span class="keyword">void</span>)foo &#123;</span><br><span class="line">    <span class="keyword">int</span> stackVariables = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">  	 _addBlock = ^ <span class="keyword">int</span> (<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">      	<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, _memberVariable);</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改 stackVariables 的值</span></span><br><span class="line">    stackVariables = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> add = addBlock(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 foo 中定义了一个 栈 Block 然后把它复制到 _addBlock 中去, 由于是从栈 copy 到堆,(这里要说一下: 在开启了 ARC 的情况下,因为编译器自动帮我们 copy 了,所以我们写 Block 的属性词时,用 copy 和 strong 都是一样的, 但是还是推荐使用 copy 啦,可以提醒我们编译器替我们做了 copy 操作😊)  Block 会持有 Block 中的变量.在 ARC 下, Block 中如果引用了 __strong 修饰符的自动变量,则相当于 Block 对该变量的引用计数+1. 由于 self 是 __strong 修饰.因此 self 持有了 Block, 同时 Block 也持有了 self.当 self 释放的时候,需要 Block 释放后才会对 self 进行释放,但是 Block 的释放又需要等 self 的 dealloc 方法中才会释放.如此一来变形成了循环引用，导致内存泄露.</p>
<p>你可能要问了,我这里并没有出现 self ?为什么 self 会被 Block 持有?</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其实 <span class="constant">_memberVariable </span>等价于 <span class="keyword">self</span>-&gt;memberVariable</span><br></pre></td></tr></table></figure>
<p>为了打破循环,我们需要取消引用可以将 self 用 __weak 所修饰</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (^AddBlock)(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AddBlock addBlock;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSString</span> *memberVariable;</span><br><span class="line">...</span><br><span class="line">- (<span class="keyword">void</span>)foo &#123;</span><br><span class="line">    <span class="keyword">int</span> stackVariables = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	 __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">  	 _addBlock = ^ <span class="keyword">int</span> (<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">      	<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, weakSelf<span class="variable">.memberVariable</span>);</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改 stackVariables 的值</span></span><br><span class="line">    stackVariables = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> add = addBlock(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__weak 变量有一个特性就是它不会影响所指向对象的生命周期,因此可以使用它来生成一个对自身对象的弱引用. 应该没有人的项目现在还不支持 ARC, 如果有, 那可以使用 __block 来打破循环. 那么__block typeof(self) weakSelf = self 就表示 Block 别再对 self 对象 retain 啦,这就打破了循环引用.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u4EC0_u4E48_u662F_Block"><a href="#u4EC0_u4E48_u662F_Block" class="headerlink" title="什么是 Block"></a>什么是 Block</h3><p>Block 翻译成中文就是块]]>
    </summary>
    
      <category term="Block" scheme="http://broccolii.github.io/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用 GitHub & Hexo 在 Mac 上搭建博客]]></title>
    <link href="http://broccolii.github.io/2014/07/08/GitHub&Hexo-Blog/"/>
    <id>http://broccolii.github.io/2014/07/08/GitHub&Hexo-Blog/</id>
    <published>2014-07-08T15:22:12.000Z</published>
    <updated>2015-12-30T09:36:11.000Z</updated>
    <content type="html"><![CDATA[<p>想搭建一个个人博客来记录一下自己学习的点滴,开发中遇到的问题,分享一下小经验.这篇文章作为 blog 的第一篇,分享一下如何基于 <a href="https://github.com" target="_blank" rel="external">GitHub</a> 和 <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a> 在 Mac 下搭建属于自己的博客.</p>
<h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><p>在搭建之前你需要一个 <a href="https://github.com" target="_blank" rel="external">GitHub</a> 账号,因为 blog 的文件都是托管在 GitHub 上的.你需要创建一个仓库 <code>+ New repository</code>,名称为 <code>GitHub用户名.github.io</code></p>
<h3 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h3><p>接下来我们会多次使用到 <a href="http://brew.sh" target="_blank" rel="external">homebrew</a></p>
<p>安装 <code>Homebrew</code> 直接使用 Mac 自带的 <code>ruby</code> 脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby <span class="operator">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>我们需要安装 <code>Git</code> 用来提交本地文件到 GitHub 的仓库中</p>
<p>推荐使用 <a href="http://brew.sh" target="_blank" rel="external">homebrew</a> 来安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install git</span><br></pre></td></tr></table></figure>
<h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>因为 <code>Hexo</code> 是基于 <code>Node.js</code> 的，所以必须安装 <code>Node.js</code> </p>
<p>继续推荐使用 <a href="http://brew.sh" target="_blank" rel="external">homebrew</a> 来安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install node</span><br></pre></td></tr></table></figure>
<p>如果你因为各种原因安装失败,又找不到解决办法.可以试一下直接下载安装包.<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a>官网下载 <code>.pkg</code> 安装包,双击安装.</p>
<p>使用以下命令输出版本号来验证是否安装成功:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">$ npm -v</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><h4 id="Hexo__u5B89_u88C5"><a href="#Hexo__u5B89_u88C5" class="headerlink" title="Hexo 安装"></a>Hexo 安装</h4><p><code>Hexo</code> 是基于 <code>Node.js</code> 实现的一款快速、简洁且高效的博客框架.</p>
<p>直接使用 <code>Node.js</code> 自带的包管理工具 <code>npm</code> 进行安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>如果因为权限问题可以使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h4 id="Hexo__u8BBE_u7F6E"><a href="#Hexo__u8BBE_u7F6E" class="headerlink" title="Hexo 设置"></a>Hexo 设置</h4><p>以下操作需要在你希望 blog 生成的路径下进行</p>
<p>1.#新建博客目录 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;blog 的本地目录名&gt;</span><br></pre></td></tr></table></figure>
<p>2.#根据当前目录下的文件生成静态网页</p>
<pre><code class="bash">$ hexo generate
</code></pre>
<p>3.#初始化依赖</p>
<pre><code class="bash">$ npm install
</code></pre>
<p>4.#启动服务</p>
<pre><code class="bash">$ hexo server
</code></pre>
<p>操作到这里时,可以在浏览器中 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 看到生成的好的 blog</p>
<h4 id="u6258_u7BA1_u5230_GitHub__u4E0A"><a href="#u6258_u7BA1_u5230_GitHub__u4E0A" class="headerlink" title="托管到 GitHub 上"></a>托管到 GitHub 上</h4><p>打开 <code>_config.yml</code>, 配置 <code>GitHub</code> 信息</p>
<pre><code class="bash">deploy:
      <span class="comment">#部署类型, 本文使用Github</span>
    <span class="built_in">type</span>: git            
    <span class="comment">#部署的仓库的链接         </span>
    repository: &lt;GitHub用户名.github.io 这个仓库所在的路径&gt;.git
    <span class="comment">#部署分支,一般使用master主分支      </span>
    branch: master
</code></pre>
<p>使用命令:</p>
<pre><code class="bash">$ hexo deploy
</code></pre>
<p>将网页发布到 GitHub 上,然后可以在 <a href="http://GitHub用户名.github.io" target="_blank" rel="external">http://GitHub用户名.github.io</a> 看到发布成功的 Blog</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>想搭建一个个人博客来记录一下自己学习的点滴,开发中遇到的问题,分享一下小经验.这篇文章作为 blog 的第一篇,分享一下如何基于 <a href="https://github.com" target="_blank" rel="external">GitHub</a> 和]]>
    </summary>
    
  </entry>
  
</feed>
